"""
Real-world integration tests for CWE/CVE enhancement with actual indexing and FCE correlation.

These tests:
1. Index real fixture projects with vulnerable dependencies
2. Query across multiple tables (findings_consolidated, symbols, function_calls, refs)
3. Test FCE-style correlation between dependency CVEs and code vulnerabilities
4. Verify multi-CWE taxonomy enables cross-cutting analysis
"""

from __future__ import annotations

import json
import os
import sqlite3
import subprocess
import tempfile
from pathlib import Path

import pytest


# Database path - populated by indexer
FIXTURES_DIR = Path(__file__).parent / "fixtures" / "vulnerabilities"
DB_PATH = Path(".pf/repo_index.db")


def fetchall(db_path: Path, query: str, params: tuple | None = None):
    """Helper to fetch all rows from database."""
    with sqlite3.connect(db_path) as conn:
        cursor = conn.cursor()
        cursor.execute(query, params or tuple())
        return cursor.fetchall()


def fetchone(db_path: Path, query: str, params: tuple | None = None):
    """Helper to fetch one row from database."""
    with sqlite3.connect(db_path) as conn:
        cursor = conn.cursor()
        cursor.execute(query, params or tuple())
        return cursor.fetchone()


# ==============================================================================
# INTEGRATION TESTS - Real Indexing + Multi-Table Queries
# ==============================================================================

def test_vulnerability_findings_have_enhanced_metadata():
    """
    INTEGRATION: Verify indexed vulnerabilities have full CWE arrays in details_json.

    Pre-condition: `aud full` or `aud index` has been run
    Queries: findings_consolidated table
    """
    db_path = DB_PATH

    # Query vulnerabilities with details_json
    vulns = fetchall(db_path, """
        SELECT rule, cwe, details_json
        FROM findings_consolidated
        WHERE tool = 'vulnerability_scanner'
        AND details_json IS NOT NULL
        AND details_json != '{}'
        LIMIT 10
    """)

    if not vulns:
        pytest.skip("No vulnerability findings with details_json - run `aud full` first")

    # Verify at least one has multi-CWE array
    multi_cwe_found = False
    for rule, cwe_primary, details_json_str in vulns:
        details = json.loads(details_json_str)

        # Check structure
        assert "cwe_ids" in details, f"{rule}: details_json missing cwe_ids"

        # Check multi-CWE
        if len(details.get("cwe_ids", [])) > 1:
            multi_cwe_found = True
            assert cwe_primary == details["cwe_ids"][0], \
                f"{rule}: Primary CWE mismatch (column: {cwe_primary}, array[0]: {details['cwe_ids'][0]})"

    assert multi_cwe_found, "No vulnerabilities with multiple CWEs found - check OSV data"


def test_fce_correlation_dependency_cve_to_code_usage():
    """
    INTEGRATION: FCE correlation - link dependency CVE to vulnerable code usage.

    Scenario:
    1. Find Django CVE-2022-28346 (SQL injection, CWE-89)
    2. Find code functions that use SQL with user input (also CWE-89)
    3. Correlate via CWE taxonomy

    Queries:
    - findings_consolidated (dependency vulns)
    - symbols (function definitions)
    - function_calls (calls to vulnerable APIs)
    - refs (imports)
    """
    db_path = DB_PATH

    # STEP 1: Find dependency vulnerabilities with CWE-89 (SQL injection)
    dep_vulns = fetchall(db_path, """
        SELECT rule, details_json
        FROM findings_consolidated
        WHERE tool = 'vulnerability_scanner'
        AND (
            cwe = 'CWE-89'
            OR details_json LIKE '%CWE-89%'
        )
    """)

    if not dep_vulns:
        pytest.skip("No CWE-89 dependency vulnerabilities found")

    # STEP 2: Find code functions that execute SQL queries
    # Look for functions calling sqlite3.execute, cursor.execute, etc.
    sql_functions = fetchall(db_path, """
        SELECT DISTINCT s.name, s.file, s.line
        FROM symbols s
        JOIN function_calls fc ON s.id = fc.context_function_id
        WHERE fc.callee_function LIKE '%execute%'
        OR fc.callee_function LIKE '%cursor.execute%'
        OR fc.callee_function LIKE '%db.execute%'
    """)

    if not sql_functions:
        pytest.skip("No SQL-executing functions found in codebase")

    # STEP 3: Correlate dependency CVE with code usage
    # Both have CWE-89, FCE can link them
    correlation_found = False
    for func_name, file, line in sql_functions:
        # Check if function uses vulnerable pattern (string formatting in SQL)
        # This would be a SAST finding with same CWE as dependency vuln
        correlation_found = True
        # In real FCE, this would trigger: "Dependency has CWE-89, code uses SQL -> HIGH RISK"

    assert len(dep_vulns) > 0, "Should have dependency vulnerabilities"
    assert len(sql_functions) > 0, "Should have code using SQL"


def test_cross_table_join_vulnerability_to_symbol_usage():
    """
    INTEGRATION: Complex join - vulnerability -> import -> symbol usage.

    Scenario:
    1. Find PyYAML CVE-2020-14343 (CWE-20, CWE-94)
    2. Find Python files importing yaml
    3. Find functions calling yaml.load (vulnerable API)
    4. Link vulnerability to specific code locations

    Queries across: findings_consolidated, refs, symbols, function_calls
    """
    db_path = DB_PATH

    # STEP 1: Find PyYAML vulnerabilities
    pyyaml_vulns = fetchall(db_path, """
        SELECT rule, details_json
        FROM findings_consolidated
        WHERE tool = 'vulnerability_scanner'
        AND (
            code_snippet LIKE '%PyYAML%'
            OR code_snippet LIKE '%pyyaml%'
        )
    """)

    if not pyyaml_vulns:
        pytest.skip("No PyYAML vulnerabilities found")

    # STEP 2: Find files importing yaml module
    yaml_imports = fetchall(db_path, """
        SELECT DISTINCT file
        FROM refs
        WHERE target LIKE '%yaml%'
        AND ref_type = 'import'
    """)

    if not yaml_imports:
        pytest.skip("No yaml imports found in codebase")

    # STEP 3: Find functions calling yaml.load (vulnerable API)
    yaml_loads = fetchall(db_path, """
        SELECT fc.file, fc.line, fc.callee_function, s.name as calling_function
        FROM function_calls fc
        LEFT JOIN symbols s ON fc.context_function_id = s.id
        WHERE fc.callee_function LIKE '%yaml.load%'
        OR fc.callee_function = 'load'
    """)

    # STEP 4: Correlate vulnerability with code usage
    # If PyYAML has CVE with CWE-94, and code calls yaml.load -> HIGH RISK
    if yaml_loads:
        for file, line, callee, calling_func in yaml_loads:
            # This is the correlation point: dependency vuln + vulnerable API usage
            assert file is not None, "Should have file for yaml.load call"
            assert line > 0, "Should have line number for yaml.load call"

    # Verify correlation data exists
    assert len(pyyaml_vulns) > 0, "Should have PyYAML vulnerability"
    assert len(yaml_imports) > 0, "Should have yaml imports"


def test_multi_cwe_taxonomy_cross_cutting_query():
    """
    INTEGRATION: Multi-CWE taxonomy enables cross-cutting security analysis.

    Scenario:
    Find all vulnerabilities (dependency + code) related to "injection" attacks.
    Injection CWEs: CWE-89 (SQL), CWE-79 (XSS), CWE-94 (code injection), CWE-77 (command injection)

    This demonstrates the value of storing full CWE arrays.
    """
    db_path = DB_PATH

    injection_cwes = ['CWE-89', 'CWE-79', 'CWE-94', 'CWE-77', 'CWE-20']

    # Query vulnerabilities with injection-related CWEs
    injection_vulns = []
    for cwe in injection_cwes:
        vulns = fetchall(db_path, f"""
            SELECT rule, cwe, details_json, tool
            FROM findings_consolidated
            WHERE cwe = '{cwe}'
            OR details_json LIKE '%{cwe}%'
        """)
        injection_vulns.extend(vulns)

    if not injection_vulns:
        pytest.skip("No injection-related vulnerabilities found")

    # Group by tool (dependency scanner vs SAST)
    dependency_vulns = [v for v in injection_vulns if v[3] == 'vulnerability_scanner']
    sast_vulns = [v for v in injection_vulns if v[3] != 'vulnerability_scanner']

    # Analyze CWE distribution
    cwe_counts = {}
    for rule, cwe_primary, details_json_str, tool in injection_vulns:
        if details_json_str:
            try:
                details = json.loads(details_json_str)
                for cwe_id in details.get("cwe_ids", [cwe_primary]):
                    cwe_counts[cwe_id] = cwe_counts.get(cwe_id, 0) + 1
            except json.JSONDecodeError:
                pass

    # Verify multi-CWE analysis is possible
    assert len(injection_vulns) > 0, "Should find injection-related vulnerabilities"
    # If we have multi-CWE vulns, cwe_counts will show the full taxonomy
    assert len(cwe_counts) >= len(injection_cwes) // 2, "Should find multiple CWE types"


def test_relationship_join_vulnerable_package_to_functions_using_it():
    """
    INTEGRATION: Join vulnerable package to all functions that import/use it.

    Scenario:
    1. Find lodash CVE-2020-8203 (prototype pollution, CWE-1321, CWE-915)
    2. Find all JavaScript files importing lodash
    3. Find all function calls to lodash methods
    4. Map vulnerability risk across codebase

    Queries: findings_consolidated, refs, function_calls, symbols
    """
    db_path = DB_PATH

    # STEP 1: Find lodash vulnerability
    lodash_vulns = fetchall(db_path, """
        SELECT rule, details_json
        FROM findings_consolidated
        WHERE tool = 'vulnerability_scanner'
        AND code_snippet LIKE '%lodash%'
    """)

    if not lodash_vulns:
        pytest.skip("No lodash vulnerabilities found")

    # STEP 2: Find lodash imports
    lodash_imports = fetchall(db_path, """
        SELECT file, line, target
        FROM refs
        WHERE target LIKE '%lodash%'
        AND ref_type = 'import'
    """)

    # STEP 3: Find lodash method calls (e.g., lodash.merge, _.merge)
    lodash_calls = fetchall(db_path, """
        SELECT fc.file, fc.line, fc.callee_function, s.name as context_function
        FROM function_calls fc
        LEFT JOIN symbols s ON fc.context_function_id = s.id
        WHERE fc.callee_function LIKE '%lodash%'
        OR fc.callee_function LIKE '%.merge%'
        OR fc.callee_function LIKE '_.%'
    """)

    # STEP 4: Build vulnerability impact map
    # For each lodash call, we know there's a CVE affecting it
    impact_locations = set()
    for file, line, callee, context_func in lodash_calls:
        impact_locations.add((file, context_func))

    # Verify relationship mapping
    if lodash_imports:
        assert len(lodash_imports) > 0, "Should have lodash imports"

    if lodash_calls:
        assert len(impact_locations) > 0, "Should map vulnerability to code locations"


def test_cve_id_direct_filter_performance():
    """
    INTEGRATION: Verify CVE ID can be filtered directly without JSON parsing.

    This tests the performance benefit of extracting cve_id to dedicated field.
    """
    db_path = DB_PATH

    # Method 1: Direct json_extract (fast)
    result1 = fetchall(db_path, """
        SELECT rule, json_extract(details_json, '$.cve_id') as cve_id
        FROM findings_consolidated
        WHERE tool = 'vulnerability_scanner'
        AND json_extract(details_json, '$.cve_id') LIKE 'CVE-2020%'
        LIMIT 5
    """)

    # Method 2: LIKE on details_json (slower, but works)
    result2 = fetchall(db_path, """
        SELECT rule, details_json
        FROM findings_consolidated
        WHERE tool = 'vulnerability_scanner'
        AND details_json LIKE '%CVE-2020%'
        LIMIT 5
    """)

    # Both methods should find results (if CVE-2020-* exists)
    # json_extract is cleaner for FCE queries
    if result1:
        for rule, cve_id in result1:
            assert cve_id.startswith('CVE-2020'), "CVE ID should match filter"


def test_backward_compatibility_existing_fce_queries():
    """
    INTEGRATION: Verify existing FCE queries still work with cwe column.

    Ensures backward compatibility - old code using cwe column works unchanged.
    """
    db_path = DB_PATH

    # Old-style query: Filter by cwe column directly
    old_style = fetchall(db_path, """
        SELECT rule, cwe
        FROM findings_consolidated
        WHERE tool = 'vulnerability_scanner'
        AND cwe IS NOT NULL
        AND cwe != ''
        LIMIT 5
    """)

    if not old_style:
        pytest.skip("No findings with cwe column populated")

    # Verify primary CWE is populated
    for rule, cwe in old_style:
        assert cwe.startswith('CWE-'), f"Primary CWE should be in column: {cwe}"


def test_cross_tool_cwe_correlation():
    """
    INTEGRATION: Correlate same CWE across different tools (SAST + vulnerability scanner).

    Scenario:
    1. Find CWE-89 (SQL injection) from dependency vuln (Django CVE)
    2. Find CWE-89 from SAST rule (hardcoded-sql-query)
    3. Correlate both findings - same weakness, different sources

    This is core FCE functionality enabled by full CWE arrays.
    """
    db_path = DB_PATH

    # Find all CWE-89 findings (both dependency and code)
    cwe_89_findings = fetchall(db_path, """
        SELECT rule, tool, file, line, details_json
        FROM findings_consolidated
        WHERE cwe = 'CWE-89'
        OR details_json LIKE '%CWE-89%'
    """)

    if not cwe_89_findings:
        pytest.skip("No CWE-89 findings found")

    # Group by tool
    by_tool = {}
    for rule, tool, file, line, details_json in cwe_89_findings:
        if tool not in by_tool:
            by_tool[tool] = []
        by_tool[tool].append((rule, file, line))

    # If we have findings from multiple tools with same CWE, correlation works
    if len(by_tool) > 1:
        # FCE can say: "Same weakness (CWE-89) found in dependency AND code"
        assert 'vulnerability_scanner' in by_tool or len(by_tool) >= 2, \
            "Should have vulnerability scanner findings"


def test_ghsa_id_extraction_and_query():
    """
    INTEGRATION: Verify GHSA IDs are extracted and queryable.

    GHSA (GitHub Security Advisory) IDs should be in details_json for direct filtering.
    """
    db_path = DB_PATH

    ghsa_findings = fetchall(db_path, """
        SELECT rule, json_extract(details_json, '$.ghsa_id') as ghsa_id
        FROM findings_consolidated
        WHERE tool = 'vulnerability_scanner'
        AND details_json LIKE '%GHSA-%'
        LIMIT 5
    """)

    if not ghsa_findings:
        pytest.skip("No GHSA findings in database")

    for rule, ghsa_id in ghsa_findings:
        assert ghsa_id.startswith('GHSA-'), f"GHSA ID should be extracted: {ghsa_id}"


def test_vulnerability_count_by_severity_and_cwe():
    """
    INTEGRATION: Multi-dimensional analysis - severity x CWE taxonomy.

    Real-world use case: "How many CRITICAL vulnerabilities have CWE-89?"
    """
    db_path = DB_PATH

    # Query: Count vulnerabilities by severity and CWE
    critical_sql_injection = fetchall(db_path, """
        SELECT COUNT(*) FROM findings_consolidated
        WHERE tool = 'vulnerability_scanner'
        AND severity IN ('critical', 'high')
        AND (cwe = 'CWE-89' OR details_json LIKE '%CWE-89%')
    """)

    critical_count = critical_sql_injection[0][0] if critical_sql_injection else 0

    # Query: Count all critical vulnerabilities
    all_critical = fetchone(db_path, """
        SELECT COUNT(*) FROM findings_consolidated
        WHERE tool = 'vulnerability_scanner'
        AND severity IN ('critical', 'high')
    """)

    total_critical = all_critical[0] if all_critical else 0

    # Verify multi-dimensional query works
    assert total_critical >= critical_count, "Total should be >= CWE-specific count"


# ==============================================================================
# REAL-WORLD SCENARIO TESTS
# ==============================================================================

def test_security_report_generation():
    """
    REAL-WORLD: Generate security report with CWE taxonomy breakdown.

    Simulates what an auditor would query:
    1. Total vulnerabilities
    2. Breakdown by CWE category
    3. Cross-tool correlation
    4. High-risk packages with multiple CVEs
    """
    db_path = DB_PATH

    # Total vulnerability count
    total = fetchone(db_path, """
        SELECT COUNT(*) FROM findings_consolidated
        WHERE tool = 'vulnerability_scanner'
    """)

    if not total or total[0] == 0:
        pytest.skip("No vulnerability findings")

    # CWE breakdown (using full arrays)
    cwe_breakdown = {}
    vulns = fetchall(db_path, """
        SELECT details_json FROM findings_consolidated
        WHERE tool = 'vulnerability_scanner'
        AND details_json IS NOT NULL
    """)

    for (details_json_str,) in vulns:
        try:
            details = json.loads(details_json_str)
            for cwe_id in details.get("cwe_ids", []):
                cwe_breakdown[cwe_id] = cwe_breakdown.get(cwe_id, 0) + 1
        except json.JSONDecodeError:
            pass

    # High-risk packages (multiple CVEs)
    high_risk_packages = fetchall(db_path, """
        SELECT code_snippet, COUNT(*) as vuln_count
        FROM findings_consolidated
        WHERE tool = 'vulnerability_scanner'
        GROUP BY code_snippet
        HAVING vuln_count > 1
        ORDER BY vuln_count DESC
    """)

    # Verify report can be generated
    assert total[0] > 0, "Should have vulnerabilities"
    assert len(cwe_breakdown) > 0, "Should have CWE breakdown"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])
