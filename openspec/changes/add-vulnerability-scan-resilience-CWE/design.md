# Design: Add Vulnerability Scan Resilience

## Verification Summary (SOP v4.20)
- package_configs is single-row-per-file (	heauditor/indexer/schema.py:789-800), so Python manifests never enter the database.
- Legacy pip-audit consumed requirements.txt from disk and ignored the DB; that path has been removed in favor of OSV-Scannerâ€™s offline PyPI coverage. _run_* helpers still lack retries/telemetry (	heauditor/vulnerability_scanner.py:63-70,147-398,442-557).
- CWE metadata is truncated to the first ID (	heauditor/vulnerability_scanner.py:520-523), and there is no manifest provenance in the DB writer pipeline (	heauditor/indexer/database.py:1420-1874).

## Goals
- Make dependency inventories database-first for all supported ecosystems, including Python manifests.
- Provide verifiable telemetry (timings, retries, manifest hashes) for each vulnerability scan.
- Preserve full vulnerability metadata (all CWE IDs) throughout ingestion and correlation.
- Maintain compatibility with existing courier consumers while enriching the JSON and database schemas.

## Non-Goals
- Replacing native scanners (npm-audit, OSV-Scanner) or changing their CLI options beyond inventory inputs.
- Altering vulnerability confidence scoring in _cross_reference.
- Introducing speculative heuristics: parsing must use structured libraries (e.g., packaging, TOML parsers) and avoid regex-only approaches.

## Architecture & Data Model
### Dependency Inventory Tables
- dependency_manifests
  - Columns: id (INTEGER PK), ile_path (TEXT, NOT NULL), manager (TEXT), manifest_type (TEXT enum: package_json, requirements_txt, pyproject, pip_tools), content_sha256 (TEXT), detected_at (TIMESTAMP), parsed_at (TIMESTAMP), source_hash (BLOB optional), workspace (TEXT optional).
  - Index on (file_path) and (manager, manifest_type).
- package_dependencies
  - Columns: manifest_id (INTEGER FK -> dependency_manifests.id), package_name (TEXT NOT NULL), 
ormalized_name (TEXT NOT NULL), specifier (TEXT), ersion_exact (TEXT), is_direct (BOOLEAN default 1), is_dev (BOOLEAN), nvironment_marker (TEXT), xtras_json (TEXT), line_number (INTEGER), source_section (TEXT), hashes_json (TEXT), manager (TEXT NOT NULL).
  - Composite primary key (manifest_id, package_name, specifier, environment_marker, extras_json) to keep duplicates out while allowing multiple specifiers per manifest.
  - Indices for (manager, normalized_name) and (manifest_id).
- Migration strategy:
  - Schema creation in 	heauditor/indexer/schema.py and database.py with idempotent DDL.
  - During ud index, purge stale rows by deleting existing manifests+dependencies for files observed in the run before inserting refreshed data.
  - Backfill staged Node data by reading existing package_configs rows and emitting dependencies into the new table on first upgrade.

### Indexer Updates
- Extend ExtractorRegistry to register new Python manifest extractors:
  - python_requirements_extractor.py: uses ManifestParser.parse_requirements_txt plus packaging.requirements.Requirement for normalization; records extras, markers, hashes.
  - python_pyproject_extractor.py: uses TOML parser to load [project.dependencies], [project.optional-dependencies], [tool.poetry.dependencies], and collects groups/environment markers deterministically.
  - pip_tools_export_extractor.py: parses .in/.txt exports produced by pip-tools, leveraging structured parsing to split name/specifier/hash.
- Update existing JsonConfigExtractor to:
  - Continue writing summaries into package_configs (backward compatibility).
  - Emit per-dependency rows to package_dependencies with manifest_id referencing the associated dependency_manifests entry.
- IndexerOrchestrator workflow:
  - For each manifest file, compute SHA-256 hash and insert/update dependency_manifests BEFORE dependency rows to obtain manifest_id for the batch.
  - Batch writers in DatabaseManager flush manifests and dependency rows transactionally (dependency_manifests_batch, package_dependencies_batch).
  - Remove obsolete manifest/dependency rows for files not present in the latest crawl via a post-run reconciliation (compare recorded manifests against FileWalker results).

### Vulnerability Scanner Execution
- Inventory loading:
  - _load_packages_from_db queries dependency_manifests joined to package_dependencies, building normalized records (manager, package, esolved_version, specifier, manifest_path, manifest_hash, provenance origin="db").
  - Parsed manifest fallback (when passed) is normalized to same schema; reconciliation marks discrepancies (origin="parsed", stale manifest hash mismatch, missing version).
  - Abort with a VulnerabilityScanError if inventory is empty after reconciliation or hashes mismatch the filesystem (manifest changed since index run).
- Tool orchestration:
  - Wrap each tool invocation in _run_with_retry(tool_name, run_callable) that records started_at/nded_at timestamps (UTC ISO-8601), duration_ms, and ttempts.
  - Retry exactly once on recoverable errors (non-zero exit, transient IO errors). Flag status as etry_succeeded or ailed_after_retry in 	ool_status.
  - Capture stderr/stdout (first N KB) and store in 	ool_status[tool]["stderr_snippet"] / stdout_snippet for diagnostics.
  - Provide skip semantics when inventory for a manager is empty (status skipped, eason).
- Inventory-aware command building:
  - When Python inventory exists, generate a temporary requirements file from DB rows for OSV-Scanner seeding (ensures consistent input and supports pyproject groups).
  - Use OSV --lockfile arguments referencing both Node and Python manifests by default.

### CWE Preservation
- Introduce inding_cwes table (inding_id FK to indings_consolidated row id, cwe_id TEXT) created alongside schema migrations.
- Modify _write_to_db:
  - Insert finding row, capture rowid, bulk insert associated CWE IDs.
  - Store cwe_ids array in the JSON artifact to remain in sync.
- Update FCE (	heauditor/fce.py) and any rules referencing inding.get('cwe') to consume arrays or join inding_cwes.

### Telemetry & Reporting
- JSON artifact changes:
  - Structure: { ..., "tool_status": { "npm-audit": {...}, "osv-scanner": {"status": "success", "attempts": 1, "started_at": "...", "ended_at": "...", "duration_ms": 1234, "stderr_snippet": "..." } }, "inventory_summary": {...}, "cwe_ids": [...] }.
  - Maintain existing keys (sources_used, 	otal_vulnerabilities) for compatibility.
- Status files:
  - Write .pf/status/vulnerability-scan.status with total duration, per-tool durations, retries, discrepancy counts.
  - Update pipeline summary (	heauditor/pipelines.py) and CLI command output to reference telemetry (e.g., npm audit succeeded in 2.3s after 1 retry).
- Logging:
  - Use structured logger to emit context on retries, manifest mismatches, and skip conditions.

## Rollout & Migration Plan
1. Ship schema migrations with backward-compatible DDL (IF NOT EXISTS, optional columns).
2. On first run post-upgrade:
   - Reindexing repopulates manifests/dependencies; fallback path reads package_configs to seed Node data until reindex occurs.
3. Document requirement to rerun ud index and ud setup-ai before relying on new telemetry.
4. Provide cleanup instructions (delete .pf/repo_index.db) if manifest hash mismatches persist.

## Testing Strategy
- Unit Tests
  - New extractors with fixtures covering extras, environment markers, multi-line specifiers, hashes.
  - Retry helper ensuring attempts/timings recorded under success, retry success, retry failure.
  - CWE serialization to JSON and DB join table.
- Integration Tests
  - End-to-end runs on repositories representing: Python-only, Node-only, mixed, and stale-manifest scenarios.
  - Simulate transient tool failure (mocked subprocess) to assert retry behavior and telemetry output.
  - Validate .pf/raw/vulnerabilities.json, .pf/status/vulnerability-scan.status, and database tables contain expected data.
- Validation
  - openspec validate add-vulnerability-scan-resilience --strict.
  - pytest, uff, mypy --strict focused on modified modules.
