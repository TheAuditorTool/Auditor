## ADDED Requirements

### Requirement: Manifest Provenance Tracking
The indexer MUST record manifest metadata so dependency rows can be traced back to a specific file revision.

#### Scenario: Manifest hash stored
- **GIVEN** ud index processes equirements.txt
- **WHEN** the run completes
- **THEN** dependency_manifests MUST contain a row for the file with manager, manifest type, SHA-256 hash, and parsed_at timestamp.

#### Scenario: Stale manifest detection
- **GIVEN** equirements.txt changes after indexing
- **WHEN** ud deps --vuln-scan runs without a fresh index
- **THEN** the scanner MUST detect the hash mismatch, refuse to use stale dependency rows, and instruct the operator to rerun ud index.

### Requirement: Per-Dependency Storage
The database MUST store each declared dependency as a dedicated row linked to its manifest.

#### Scenario: Python requirements captured
- **GIVEN** equirements.txt lists Django==4.2.5
- **WHEN** ud index finishes
- **THEN** package_dependencies MUST contain a row with manager: "pip", package_name: "Django", ersion_exact: "4.2.5", and a foreign key to the corresponding manifest.

#### Scenario: Node manifest dual-write
- **GIVEN** package.json declares { "dependencies": { "react": "18.2.0" } }
- **WHEN** the indexer runs
- **THEN** the same dependency MUST be represented both in package_configs (for backward compatibility) and as a row in package_dependencies referencing the manifest metadata.

### Requirement: Reindex Hygiene
Reindexing MUST replace stale dependency rows instead of accumulating duplicates or orphaned data.

#### Scenario: Manifest removed from repository
- **GIVEN** a workspace deletes rontend/package.json
- **WHEN** ud index runs after the deletion
- **THEN** the database MUST remove the corresponding manifest and dependency rows so subsequent scans ignore the old package.

#### Scenario: Idempotent indexing
- **GIVEN** ud index is executed twice without repository changes
- **WHEN** the second run finishes
- **THEN** dependency_manifests and package_dependencies MUST contain identical data (no duplicates, identical hash/timestamp where appropriate).