# Design: Update Vulnerability Scan Pipeline

## Verification Summary (SOP v4.20)
- `theauditor/vulnerability_scanner.py:71-122` exits early when `package_configs` is empty, so `_write_to_json` at `theauditor/vulnerability_scanner.py:724-759` never runs and `.pf/raw/vulnerabilities.json` is skipped.
- `theauditor/indexer/extractors/json_config.py:42-104` only writes Node metadata into `package_configs`, leaving Python manifests (`requirements.txt`, `pyproject.toml`) unused even though `parse_dependencies` captures them.
- `theauditor/vulnerability_scanner.py:775-815` catches native tool failures and returns an empty list, and `theauditor/commands/deps.py:84-123` interprets that empty list as success, printing `[OK]` despite missing evidence.
- `openspec/changes/update-vulnerability-scan-pipeline/specs/security/vulnerability-scanning/spec.md` now requires complete inventory coverage, deterministic artifacts, and explicit failure states; current behavior violates all three requirements.

## Goals
- Guarantee `package_configs` mirrors every supported dependency manifest (Python, Node, and future ecosystems) so scanners always have inventory.
- Let `VulnerabilityScanner.scan()` reconcile database rows with freshly parsed manifests, falling back to parsed data when gaps exist and logging discrepancies.
- Emit `.pf/raw/vulnerabilities.json` on every run with `sources_used`, per-tool `tool_status`, and success/failure metadata, even for zero findings.
- Treat missing tooling, empty inventories, or command failures as hard errors that surface through the CLI, pipeline summary, and downstream automation.

## Non-Goals
- Changing vulnerability detection heuristics or cross-referencing logic in `_cross_reference` (`theauditor/vulnerability_scanner.py:511-632`).
- Replacing existing native scanners (npm audit, pip-audit, OSV-Scanner) or modifying their installation workflow.
- Schema migrations for SQLite artifacts beyond `package_configs`; the change must remain compatible with existing databases.

## Indexing Contract Expansion
- Introduce Python manifest extractors under `theauditor/indexer/extractors/` to normalize `requirements*.txt`, `pip-tools` exports, and Poetry/TOML data into the same `package_configs` schema (fields: `file_path`, `package_name`, `version`, `metadata` map).
  - Create `python_requirements.py` to parse requirements-style files using `theauditor.manifest_parser` helpers.
  - Extend `pyproject` parsing (likely `theauditor/manifest_parser.py:215-362`) to surface `[tool.poetry.dependencies]` and `project.dependencies`.
  - Update the indexer registry (`theauditor/indexer/__init__.py` and `theauditor/indexer/registry.py`) so these extractors run during `aud index`.
- Ensure `package_configs` rows include `package_manager` (e.g., `pip`, `poetry`, `npm`) so the scanner can route manifests without path sniffing. Add lightweight migration logic that backfills `package_manager` as rows are rewritten.
- Update fixtures and tests:
  - Seed mixed-language fixtures under `tests/integration/indexer/` with both Node and Python manifests, asserting `aud index` populates `package_configs` for all relevant rows.
  - Add unit coverage around the new extractor functions with representative manifest snippets (extras, environment markers, hashes).

## Scanner Inventory Reconciliation
- Refactor `_load_packages_from_db` to return typed inventory objects including `manager`, `name`, `version`, `source_path`, and `origin` (`db` vs `parsed`). Track discovered duplicates and missing versions.
- Build `VulnerabilityScanner._load_packages_from_manifests(self, manifests: List[Dict[str, Any]])` that normalizes `deps_list` entries (when provided) into the same structure. `scan_dependencies` can pass the parsed inventory so the scanner has a fallback without double parsing.
- Modify `scan()` to:
  1. Load DB inventory and parsed inventory (when `deps_list` provided).
  2. Use a reconciliation helper that:
     - Prefers DB rows.
     - Adds parsed-only packages flagged as `origin="parsed"` with a discrepancy log entry.
     - Marks DB packages missing from parsed data so auditors can see stale rows.
  3. Abort with a structured error if both inventories are empty.
- Emit discrepancy events via `logger.warning` and structured telemetry (new list `self.inventory_discrepancies`) so `.pf/raw/vulnerabilities.json` can record them under `inventory_notes`.

## Error Handling & Tool Status
- Define a `VulnerabilityScanError` (subclass of `RuntimeError`) carrying `phase` and `details`. Raise it when:
  - Inventory is empty after reconciliation.
  - Required binaries (`pip-audit`, `osv-scanner`, `npm`) fail discovery checks in `_ensure_tool_available` (new helper).
  - Native command launches return non-zero; capture stderr/stdout snippets.
- Wrap each tool invocation (`_run_npm_audit`, `_run_pip_audit`, `_run_osv_scanner`) with try/except that records `tool_status` entries (`status`, `error`, `started_at`, `ended_at`). On failure mark the status, raise `VulnerabilityScanError`, and skip silent fallthrough.
- Update `scan_dependencies` to:
  - Accept `deps_list` for transient fallback.
  - Catch `VulnerabilityScanError`, log via `logger.error`, and re-raise so CLI callers can surface non-zero exits.
  - Ensure unexpected exceptions propagate after adding context.

## Artifact Production & Reporting
- Create `VulnerabilityArtifact` data builder that receives findings, `tool_status`, `inventory_summary`, and `discrepancies`.
- Always call `_write_to_json` with a populated payload:
  ```json
  {
    "timestamp": "...",
    "total_vulnerabilities": 0,
    "findings": [],
    "sources_used": ["npm-audit", "pip-audit", "osv-scanner"],
    "tool_status": {
      "npm-audit": {"status": "error", "error": "missing binary", "...": "..."},
      "pip-audit": {"status": "skipped", "reason": "inventory-empty"}
    },
    "inventory_notes": [...],
    "failure": {"phase": "inventory", "message": "..."}  # optional
  }
  ```
- Update `theauditor/commands/deps.py:68-142` so:
  - `scan_dependencies` failures bubble up; catch `VulnerabilityScanError`, print a `[FAIL]` block, and exit with a non-zero code.
  - On success (even zero findings), print a short summary referencing the JSON artifact path and `sources_used`.
- Extend pipeline summary logic in `theauditor/pipelines.py:1180-1330` to ingest the enriched JSON and display counts plus failed tool reasons. Ensure the phase summary reflects failure states instead of silently succeeding.

## Logging & Observability
- Add structured logging helpers in `theauditor/vulnerability_scanner.py` so discrepancy and tool failure events include repository path, manifest type, and remediation guidance.
- Write pipeline status snapshots under `.pf/status/vulnerability-scan.status` with success/failure counts and elapsed time, mirroring other pipeline tracks.
- Ensure logs align with SOP verify-before-acting messaging: state which prerequisite is missing and how to restore (`aud setup tools`, rerun `aud index`, etc.).

## Testing & Validation
- Unit tests:
  - `tests/unit/indexer/test_python_manifest_extractors.py` for new extractor edge cases (extras, constraints, comments).
  - `tests/unit/vulnerability_scanner/test_inventory_reconciliation.py` for fallback behavior and discrepancy logging.
  - `tests/unit/vulnerability_scanner/test_tool_status.py` to assert failures raise `VulnerabilityScanError` with recorded metadata.
- Integration tests:
  - Extend existing dependency fixtures to run `aud index` + `aud deps --vuln-scan` for Python-only, Node-only, and mixed repositories. Assert `.pf/raw/vulnerabilities.json` exists, contains `tool_status`, and mirrors spec requirements.
  - Introduce failure-mode fixtures (missing pip-audit binary) to ensure CLI exits non-zero and artifact captures the failure.
- Validation:
  - `openspec validate update-vulnerability-scan-pipeline --strict`.
  - `pytest`, `ruff`, `mypy --strict` on affected modules.
  - Manual dry-run on sample repositories to confirm discrepancy logs and pipeline summary output.

## Rollout Considerations
- Document in `security` documentation (Task 4.1) that `aud index` must be re-run after upgrading to populate Python manifests.
- Recommend users rerun `aud setup tools` to ensure required binaries exist before executing the updated pipeline.
- Provide a migration note in release docs advising teams to clear stale `.pf/repo_index.db` caches if discrepancies persist after reindexing.
