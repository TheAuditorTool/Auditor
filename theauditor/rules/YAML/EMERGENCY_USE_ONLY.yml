# âš ï¸ BREAK GLASS IN CASE OF EMERGENCY âš ï¸
#
# This pattern-based detection system should ONLY be used for TRUE edge cases
# where database-first rules and AST parsers cannot work.
#
# ğŸš¨ CRITICAL LESSONS LEARNED ğŸš¨
#
# DO NOT USE THIS FOR:
# âŒ Docker configurations  â†’ Use docker_analyze.py (AST-based with dockerfile-parse)
# âŒ Nginx configurations   â†’ Use nginx_analyze.py (AST-based with nginx parser)
# âŒ SQL/PostgreSQL patterns â†’ Use multi_tenant_analyze.py (database queries)
# âŒ Python/JavaScript code  â†’ Use language-specific analyzers
# âŒ ANY format with AST parser â†’ Always prefer database-first rules
#
# WHY THIS SYSTEM EXISTS:
# - Pattern-based detection is SLOWER (file scanning vs indexed queries)
# - Pattern-based detection is LESS ACCURATE (regex vs semantic analysis)
# - Pattern-based detection creates REDUNDANCY (duplicate findings)
# - Database-first rules are the GOLD STANDARD architecture
#
# ğŸ¯ WHEN TO USE PATTERN-BASED DETECTION:
#
# ONLY use this for formats WITHOUT AST parsers or database extraction:
# âœ… .env files (environment variable validation)
# âœ… .htaccess files (Apache configurations)
# âœ… Custom config formats (proprietary formats without parsers)
# âœ… Binary file metadata (when text patterns indicate issues)
# âœ… Ad-hoc security scans (temporary patterns for specific audits)
#
# ğŸ“‹ TEMPLATE STRUCTURE:
#
# patterns:
#   - name: "unique-pattern-name"
#     description: "Clear description of what this detects"
#     regex: "your-regex-pattern-here"
#     languages: ["env", "htaccess"]  # Target file extensions
#     severity: "high"  # low, medium, high, critical
#
#     # Optional fields:
#     confidence: 0.8  # 0.0-1.0 confidence score
#     files: ["*.env", ".htaccess"]  # File patterns to scan
#     examples:
#       - "DB_PASSWORD=hardcoded123"  # What triggers this pattern
#     counter_examples:
#       - "DB_PASSWORD=${SECRET}"  # What should NOT trigger
#
# ğŸ” VERIFICATION CHECKLIST BEFORE ADDING PATTERNS:
#
# 1. â–¡ Check if an AST parser exists for this file type
#    â†’ Search: "python [filetype] parser" on PyPI
#    â†’ If exists: Create extractor + database-first rule instead
#
# 2. â–¡ Check if database-first rule already covers this
#    â†’ Search codebase: grep -r "pattern_name" theauditor/rules/
#    â†’ Review: theauditor/indexer/extractors/
#
# 3. â–¡ Verify this is a TRUE edge case (no AST/DB alternative)
#    â†’ Document why database-first won't work
#    â†’ Get approval before adding patterns
#
# 4. â–¡ Test pattern accuracy with examples/counter_examples
#    â†’ Run: aud detect-patterns --categories your_category
#    â†’ Verify: No false positives, catches true issues
#
# ğŸ“Š PATTERN CATEGORIES:
#
# Create separate .yml files for different categories:
# - env_patterns.yml        â†’ Environment variable security
# - htaccess_patterns.yml   â†’ Apache configuration issues
# - custom_patterns.yml     â†’ Project-specific temporary patterns
#
# ğŸš€ USAGE:
#
# aud detect-patterns                    # Run all YAML patterns
# aud detect-patterns --categories env   # Run specific category
#
# This command is included in `aud full` pipeline (pipelines.py:422)
# If no patterns exist, it returns 0 findings (no performance cost)
#
# ğŸ—ï¸ ARCHITECTURE NOTES:
#
# Pattern Loading: pattern_loader.py (line 52 â†’ rules/YAML/*.yml)
# Detection Engine: universal_detector.py
# CLI Command: commands/detect_patterns.py
# Pipeline Integration: pipelines.py:422
#
# The database-first rule system (base.py, orchestrator.py) is COMPLETELY
# ISOLATED from this pattern system. They do not interact.
#
# ğŸ“ HISTORICAL CONTEXT:
#
# Previous config_patterns.yml contained:
# - 3 Docker patterns (100% redundant with docker_analyze.py)
# - 3 Nginx patterns (100% redundant with nginx_analyze.py)
# - 2 PostgreSQL RLS patterns (100% redundant with multi_tenant_analyze.py)
#
# Result: Zero unique value, architectural redundancy, deleted 2025-10-04
#
# Lesson: ALWAYS check if database-first rule exists before adding patterns here.
#
# ğŸ“ EXAMPLE: .env File Security Patterns (TRUE EDGE CASE)
#
# patterns:
#   - name: "env-hardcoded-secret"
#     description: "Hardcoded secrets in .env files"
#     regex: '^[A-Z_]+=((?!(\$\{|changeme|REPLACE|TODO)).{8,})'
#     languages: ["env"]
#     severity: "critical"
#     files: ["*.env", ".env*"]
#     examples:
#       - "API_KEY=sk_live_1234567890abcdef"
#       - "DB_PASSWORD=MySecretPass123"
#     counter_examples:
#       - "API_KEY=${VAULT_API_KEY}"  # Using secret manager
#       - "DB_PASSWORD=changeme"      # Placeholder
#
#   - name: "env-missing-quotes"
#     description: "Unquoted values with special chars in .env"
#     regex: '^[A-Z_]+=.*[\s$`].*(?<!")$'
#     languages: ["env"]
#     severity: "medium"
#     files: ["*.env"]
#
# Remember: This is a LAST RESORT tool. Database-first rules are always superior.

# Uncomment and add patterns ONLY for true edge cases:
# patterns: []
