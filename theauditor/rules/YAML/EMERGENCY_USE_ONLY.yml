# ⚠️ BREAK GLASS IN CASE OF EMERGENCY ⚠️
#
# This pattern-based detection system should ONLY be used for TRUE edge cases
# where database-first rules and AST parsers cannot work.
#
# 🚨 CRITICAL LESSONS LEARNED 🚨
#
# DO NOT USE THIS FOR:
# ❌ Docker configurations  → Use docker_analyze.py (AST-based with dockerfile-parse)
# ❌ Nginx configurations   → Use nginx_analyze.py (AST-based with nginx parser)
# ❌ SQL/PostgreSQL patterns → Use multi_tenant_analyze.py (database queries)
# ❌ Python/JavaScript code  → Use language-specific analyzers
# ❌ ANY format with AST parser → Always prefer database-first rules
#
# WHY THIS SYSTEM EXISTS:
# - Pattern-based detection is SLOWER (file scanning vs indexed queries)
# - Pattern-based detection is LESS ACCURATE (regex vs semantic analysis)
# - Pattern-based detection creates REDUNDANCY (duplicate findings)
# - Database-first rules are the GOLD STANDARD architecture
#
# 🎯 WHEN TO USE PATTERN-BASED DETECTION:
#
# ONLY use this for formats WITHOUT AST parsers or database extraction:
# ✅ .env files (environment variable validation)
# ✅ .htaccess files (Apache configurations)
# ✅ Custom config formats (proprietary formats without parsers)
# ✅ Binary file metadata (when text patterns indicate issues)
# ✅ Ad-hoc security scans (temporary patterns for specific audits)
#
# 📋 TEMPLATE STRUCTURE:
#
# patterns:
#   - name: "unique-pattern-name"
#     description: "Clear description of what this detects"
#     regex: "your-regex-pattern-here"
#     languages: ["env", "htaccess"]  # Target file extensions
#     severity: "high"  # low, medium, high, critical
#
#     # Optional fields:
#     confidence: 0.8  # 0.0-1.0 confidence score
#     files: ["*.env", ".htaccess"]  # File patterns to scan
#     examples:
#       - "DB_PASSWORD=hardcoded123"  # What triggers this pattern
#     counter_examples:
#       - "DB_PASSWORD=${SECRET}"  # What should NOT trigger
#
# 🔍 VERIFICATION CHECKLIST BEFORE ADDING PATTERNS:
#
# 1. □ Check if an AST parser exists for this file type
#    → Search: "python [filetype] parser" on PyPI
#    → If exists: Create extractor + database-first rule instead
#
# 2. □ Check if database-first rule already covers this
#    → Search codebase: grep -r "pattern_name" theauditor/rules/
#    → Review: theauditor/indexer/extractors/
#
# 3. □ Verify this is a TRUE edge case (no AST/DB alternative)
#    → Document why database-first won't work
#    → Get approval before adding patterns
#
# 4. □ Test pattern accuracy with examples/counter_examples
#    → Run: aud detect-patterns --categories your_category
#    → Verify: No false positives, catches true issues
#
# 📊 PATTERN CATEGORIES:
#
# Create separate .yml files for different categories:
# - env_patterns.yml        → Environment variable security
# - htaccess_patterns.yml   → Apache configuration issues
# - custom_patterns.yml     → Project-specific temporary patterns
#
# 🚀 USAGE:
#
# aud detect-patterns                    # Run all YAML patterns
# aud detect-patterns --categories env   # Run specific category
#
# This command is included in `aud full` pipeline (pipelines.py:422)
# If no patterns exist, it returns 0 findings (no performance cost)
#
# 🏗️ ARCHITECTURE NOTES:
#
# Pattern Loading: pattern_loader.py (line 52 → rules/YAML/*.yml)
# Detection Engine: universal_detector.py
# CLI Command: commands/detect_patterns.py
# Pipeline Integration: pipelines.py:422
#
# The database-first rule system (base.py, orchestrator.py) is COMPLETELY
# ISOLATED from this pattern system. They do not interact.
#
# 🎓 HISTORICAL CONTEXT:
#
# Previous config_patterns.yml contained:
# - 3 Docker patterns (100% redundant with docker_analyze.py)
# - 3 Nginx patterns (100% redundant with nginx_analyze.py)
# - 2 PostgreSQL RLS patterns (100% redundant with multi_tenant_analyze.py)
#
# Result: Zero unique value, architectural redundancy, deleted 2025-10-04
#
# Lesson: ALWAYS check if database-first rule exists before adding patterns here.
#
# 📝 EXAMPLE: .env File Security Patterns (TRUE EDGE CASE)
#
# patterns:
#   - name: "env-hardcoded-secret"
#     description: "Hardcoded secrets in .env files"
#     regex: '^[A-Z_]+=((?!(\$\{|changeme|REPLACE|TODO)).{8,})'
#     languages: ["env"]
#     severity: "critical"
#     files: ["*.env", ".env*"]
#     examples:
#       - "API_KEY=sk_live_1234567890abcdef"
#       - "DB_PASSWORD=MySecretPass123"
#     counter_examples:
#       - "API_KEY=${VAULT_API_KEY}"  # Using secret manager
#       - "DB_PASSWORD=changeme"      # Placeholder
#
#   - name: "env-missing-quotes"
#     description: "Unquoted values with special chars in .env"
#     regex: '^[A-Z_]+=.*[\s$`].*(?<!")$'
#     languages: ["env"]
#     severity: "medium"
#     files: ["*.env"]
#
# Remember: This is a LAST RESORT tool. Database-first rules are always superior.

# Uncomment and add patterns ONLY for true edge cases:
# patterns: []
