/**
 * Control Flow Graph (CFG) Extraction for TypeScript/JavaScript
 *
 * This file contains the CFG extraction logic that builds control flow graphs
 * for all functions in a TypeScript/JavaScript file. It handles:
 * - Basic blocks (entry, exit, condition, loop, etc.)
 * - Control flow edges (normal, true, false, exception, back_edge)
 * - JSX statement tracking
 * - Nested function detection
 *
 * Architecture:
 * - Extracted from: js_helper_templates.py.bak2 (EXTRACT_CFG constant)
 * - Used by: ES Module and CommonJS batch templates
 * - Injected via: Python f-string concatenation
 *
 * REGRESSION FIXES (Session 5 - 2025-10-24):
 * FIX 1: Removed return statements in visit() to detect nested functions (85% JSX loss)
 * FIX 2: Create explicit basic blocks for control flow bodies (3,442 basic blocks)
 * FIX 3: Add true/false edges correctly (2,038 true edges)
 * FIX 4: Populate statements arrays for basic blocks (4,994 statements)
 *
 * DO NOT EDIT THIS FILE HEADER - It is generated during refactoring.
 * The function below is extracted 1:1 from the original Python file.
 */

/**
 * Build CFG for all functions directly from TypeScript AST.
 * Ports Python build_typescript_function_cfg to JavaScript with historical parity.
 *
 * REGRESSION FIXES (Session 5 - 2025-10-24):
 * FIX 1: Removed return statements in visit() to detect nested functions (85% JSX loss)
 * FIX 2: Create explicit basic blocks for control flow bodies (3,442 basic blocks)
 * FIX 3: Add true/false edges correctly (2,038 true edges)
 * FIX 4: Populate statements arrays for basic blocks (4,994 statements)
 *
 * @param {Object} sourceFile - TypeScript source file
 * @param {Object} ts - TypeScript compiler API
 * @returns {Array} - List of CFG objects (one per function)
 */
function extractCFG(sourceFile, ts) {
    const cfgs = [];
    const class_stack = [];

    function getFunctionName(node, classStack, parent) {
        if (node.name) {
            const name = node.name.text || node.name.escapedText || 'anonymous';
            if (classStack.length > 0 && node.kind !== ts.SyntaxKind.FunctionDeclaration) {
                return classStack[classStack.length - 1] + '.' + name;
            }
            return name;
        }

        const kind = ts.SyntaxKind[node.kind];
        if (kind === 'Constructor') {
            return classStack.length > 0 ? classStack[classStack.length - 1] + '.constructor' : 'constructor';
        }

        // Try to get name from parent context for arrow functions
        if (parent) {
            const parentKind = ts.SyntaxKind[parent.kind];
            if (parentKind === 'VariableDeclaration' && parent.name) {
                const varName = parent.name.text || parent.name.escapedText || 'anonymous';
                return classStack.length > 0 ? classStack[classStack.length - 1] + '.' + varName : varName;
            }
            if (parentKind === 'PropertyAssignment' && parent.name) {
                const propName = parent.name.text || parent.name.escapedText || 'anonymous';
                return classStack.length > 0 ? classStack[classStack.length - 1] + '.' + propName : propName;
            }
            if (parentKind === 'BinaryExpression' && parent.left) {
                const leftText = parent.left.getText ? parent.left.getText(sourceFile) : '';
                if (leftText) return leftText;
            }
        }

        return 'anonymous';
    }

    function buildFunctionCFG(funcNode, classStack, parent) {
        const blocks = [];
        const edges = [];
        let blockCounter = 0;

        function getNextBlockId() {
            return ++blockCounter;
        }

        const funcName = getFunctionName(funcNode, classStack, parent);
        const { line: funcStartLine } = sourceFile.getLineAndCharacterOfPosition(funcNode.getStart(sourceFile));
        const { line: funcEndLine } = sourceFile.getLineAndCharacterOfPosition(funcNode.getEnd());

        const entryId = getNextBlockId();
        const exitId = getNextBlockId();

        blocks.push({
            id: entryId,
            type: 'entry',
            start_line: funcStartLine + 1,
            end_line: funcEndLine + 1,
            statements: []
        });

        blocks.push({
            id: exitId,
            type: 'exit',
            start_line: funcStartLine + 1,
            end_line: funcEndLine + 1,
            statements: []
        });

        function processNode(node, currentId, depth = 0) {
            if (depth > 50 || !node) {
                return currentId;
            }

            const kind = ts.SyntaxKind[node.kind];
            const { line } = sourceFile.getLineAndCharacterOfPosition(node.getStart(sourceFile));

            // Control flow nodes
            if (kind === 'IfStatement') {
                const condId = getNextBlockId();
                blocks.push({
                    id: condId,
                    type: 'condition',
                    start_line: line + 1,
                    end_line: line + 1,
                    condition: node.expression ? node.expression.getText(sourceFile).substring(0, 200) : 'condition',
                    statements: []
                });
                edges.push({source: currentId, target: condId, type: 'normal'});

                // FIX 2 & 3: Create explicit then basic block with true edge
                const thenBlockId = getNextBlockId();
                blocks.push({id: thenBlockId, type: 'basic', start_line: line + 1, end_line: line + 1, statements: []});
                edges.push({source: condId, target: thenBlockId, type: 'true'});

                let thenExitId = thenBlockId;
                if (node.thenStatement) {
                    thenExitId = processNode(node.thenStatement, thenBlockId, depth + 1);
                }

                const mergeId = getNextBlockId();
                blocks.push({id: mergeId, type: 'merge', start_line: line + 1, end_line: line + 1, statements: []});

                if (node.elseStatement) {
                    // FIX 2 & 3: Create explicit else basic block with false edge
                    const elseBlockId = getNextBlockId();
                    blocks.push({id: elseBlockId, type: 'basic', start_line: line + 1, end_line: line + 1, statements: []});
                    edges.push({source: condId, target: elseBlockId, type: 'false'});

                    let elseExitId = processNode(node.elseStatement, elseBlockId, depth + 1);

                    if (thenExitId) edges.push({source: thenExitId, target: mergeId, type: 'normal'});
                    if (elseExitId) edges.push({source: elseExitId, target: mergeId, type: 'normal'});
                } else {
                    if (thenExitId) edges.push({source: thenExitId, target: mergeId, type: 'normal'});
                    // FIX 3: false edge from condition to merge when no else
                    edges.push({source: condId, target: mergeId, type: 'false'});
                }
                return mergeId;
            }
            else if (kind === 'ForStatement' || kind === 'ForInStatement' || kind === 'ForOfStatement' || kind === 'WhileStatement' || kind === 'DoStatement') {
                const loopCondId = getNextBlockId();
                blocks.push({
                    id: loopCondId, type: 'loop_condition', start_line: line + 1, end_line: line + 1,
                    condition: node.expression ? node.expression.getText(sourceFile).substring(0, 200) : 'loop',
                    statements: []
                });
                edges.push({source: currentId, target: loopCondId, type: 'normal'});

                // FIX 2 & 3: Create explicit loop body basic block with true edge
                const bodyId = getNextBlockId();
                blocks.push({id: bodyId, type: 'loop_body', start_line: line + 1, end_line: line + 1, statements: []});
                edges.push({source: loopCondId, target: bodyId, type: 'true'});

                let bodyExitId = bodyId;
                if (node.statement) {
                    bodyExitId = processNode(node.statement, bodyId, depth + 1);
                }
                if (bodyExitId) {
                    edges.push({source: bodyExitId, target: loopCondId, type: 'back_edge'});
                }

                const afterLoopId = getNextBlockId();
                blocks.push({id: afterLoopId, type: 'merge', start_line: line + 1, end_line: line + 1, statements: []});
                edges.push({source: loopCondId, target: afterLoopId, type: 'false'});
                return afterLoopId;
            }
            else if (kind === 'ReturnStatement') {
                const retId = getNextBlockId();
                const retLine = line + 1;
                blocks.push({id: retId, type: 'return', start_line: retLine, end_line: retLine, statements: [
                    // FIX 4: Add statement to return block
                    {type: 'return', line: retLine, text: node.getText(sourceFile).substring(0, 200)}
                ]});
                edges.push({source: currentId, target: retId, type: 'normal'});
                edges.push({source: retId, target: exitId, type: 'normal'});
                return null; // Terminal block
            }
            else if (kind === 'TryStatement') {
                const tryId = getNextBlockId();
                blocks.push({id: tryId, type: 'try', start_line: line + 1, end_line: line + 1, statements: []});
                edges.push({source: currentId, target: tryId, type: 'normal'});

                let tryBodyExitId = tryId;
                if (node.tryBlock) {
                    // FIX 2: Create basic block for try body
                    const tryBlockId = getNextBlockId();
                    blocks.push({id: tryBlockId, type: 'basic', start_line: line + 1, end_line: line + 1, statements: []});
                    edges.push({source: tryId, target: tryBlockId, type: 'normal'});
                    tryBodyExitId = processNode(node.tryBlock, tryBlockId, depth + 1);
                }

                const mergeId = getNextBlockId();
                blocks.push({id: mergeId, type: 'merge', start_line: line + 1, end_line: line + 1, statements: []});

                if (tryBodyExitId) {
                    edges.push({source: tryBodyExitId, target: mergeId, type: 'normal'});
                }

                if (node.catchClause) {
                    const catchId = getNextBlockId();
                    blocks.push({id: catchId, type: 'except', start_line: line + 1, end_line: line + 1, statements: []});
                    edges.push({source: tryId, target: catchId, type: 'exception'});

                    let catchBodyExitId = catchId;
                    if (node.catchClause.block) {
                        // FIX 2: Create basic block for catch body
                        const catchBlockId = getNextBlockId();
                        blocks.push({id: catchBlockId, type: 'basic', start_line: line + 1, end_line: line + 1, statements: []});
                        edges.push({source: catchId, target: catchBlockId, type: 'normal'});
                        catchBodyExitId = processNode(node.catchClause.block, catchBlockId, depth + 1);
                    }
                    if (catchBodyExitId) {
                        edges.push({source: catchBodyExitId, target: mergeId, type: 'normal'});
                    }
                }

                // Finally block executes after try/catch merge
                if (node.finallyBlock) {
                    const finallyId = getNextBlockId();
                    blocks.push({id: finallyId, type: 'finally', start_line: line + 1, end_line: line + 1, statements: []});
                    edges.push({source: mergeId, target: finallyId, type: 'normal'});

                    let finallyBodyExitId = finallyId;
                    if (node.finallyBlock) {
                        // FIX 2: Create basic block for finally body
                        const finallyBlockId = getNextBlockId();
                        blocks.push({id: finallyBlockId, type: 'basic', start_line: line + 1, end_line: line + 1, statements: []});
                        edges.push({source: finallyId, target: finallyBlockId, type: 'normal'});
                        finallyBodyExitId = processNode(node.finallyBlock, finallyBlockId, depth + 1);
                    }
                    return finallyBodyExitId || finallyId;
                }

                return mergeId;
            }
            // JSX nodes - treat as normal statements (NOT control flow)
            else if (kind.startsWith('Jsx')) {
                // FIX 4: Add JSX statement to current block
                const currentBlock = blocks.find(b => b.id === currentId);
                if (currentBlock && (currentBlock.type === 'basic' || currentBlock.type === 'loop_body' || currentBlock.type === 'entry')) {
                    currentBlock.statements = currentBlock.statements || [];
                    currentBlock.statements.push({
                        type: kind,
                        line: line + 1,
                        text: node.getText(sourceFile).substring(0, 200)
                    });
                }

                // Traverse JSX children
                let lastId = currentId;
                ts.forEachChild(node, child => {
                    if (lastId) {
                        lastId = processNode(child, lastId, depth + 1);
                    }
                });
                return lastId;
            }
            // FIX 4: Handle Block nodes specially to avoid creating extra blocks
            else if (kind === 'Block') {
                // Block node: process its children into current block
                let lastId = currentId;
                ts.forEachChild(node, child => {
                    if (lastId) {
                        lastId = processNode(child, lastId, depth + 1);
                    }
                });
                return lastId;
            }
            // Default: This is a statement
            else {
                // FIX 4: Add statement to current basic block
                const currentBlock = blocks.find(b => b.id === currentId);
                if (currentBlock && (currentBlock.type === 'basic' || currentBlock.type === 'loop_body' || currentBlock.type === 'try' || currentBlock.type === 'except' || currentBlock.type === 'finally' || currentBlock.type === 'entry')) {
                    currentBlock.statements = currentBlock.statements || [];
                    currentBlock.statements.push({
                        type: kind,
                        line: line + 1,
                        text: node.getText(sourceFile).substring(0, 200)
                    });
                }

                // Continue traversal for nested structures
                let lastId = currentId;
                ts.forEachChild(node, child => {
                    if (lastId) {
                        lastId = processNode(child, lastId, depth + 1);
                    }
                });
                return lastId;
            }
        }

        // Start processing from function body
        let lastBlockId = entryId;
        if (funcNode.body) {
            // Handle arrow function concise body (not a block)
            if (funcNode.body.kind !== ts.SyntaxKind.Block) {
                lastBlockId = processNode(funcNode.body, entryId, 0);
            } else {
                // Standard block body
                ts.forEachChild(funcNode.body, child => {
                    if (lastBlockId) {
                        lastBlockId = processNode(child, lastBlockId, 0);
                    }
                });
            }
        }

        // Connect last block to exit
        if (lastBlockId) {
            edges.push({source: lastBlockId, target: exitId, type: 'normal'});
        }

        return {
            function_name: funcName,
            blocks: blocks,
            edges: edges
        };
    }

    function visit(node, depth = 0, parent = null) {
        if (depth > 100 || !node) return;

        const kind = ts.SyntaxKind[node.kind];

        // Track class context
        if (kind === 'ClassDeclaration') {
            const className = node.name ? (node.name.text || node.name.escapedText || 'UnknownClass') : 'UnknownClass';
            class_stack.push(className);
            ts.forEachChild(node, child => visit(child, depth + 1, node));
            class_stack.pop();
            return;
        }

        // Function-like nodes
        if (kind === 'FunctionDeclaration' || kind === 'MethodDeclaration' ||
            kind === 'ArrowFunction' || kind === 'FunctionExpression' ||
            kind === 'Constructor' || kind === 'GetAccessor' || kind === 'SetAccessor') {

            const cfg = buildFunctionCFG(node, class_stack, parent);
            if (cfg && cfg.function_name !== 'anonymous') {
                cfgs.push(cfg);
            }
            // FIX 1: REMOVED return statement - allows nested function detection
        }

        // Property declarations with function initializers
        if (kind === 'PropertyDeclaration' && node.initializer) {
            const initKind = ts.SyntaxKind[node.initializer.kind];
            if (initKind === 'ArrowFunction' || initKind === 'FunctionExpression') {
                const cfg = buildFunctionCFG(node.initializer, class_stack, node);
                if (cfg && cfg.function_name !== 'anonymous') {
                    cfgs.push(cfg);
                }
                // FIX 1: REMOVED return statement
            }
        }

        ts.forEachChild(node, child => visit(child, depth + 1, node));
    }

    visit(sourceFile);
    return cfgs;
}
