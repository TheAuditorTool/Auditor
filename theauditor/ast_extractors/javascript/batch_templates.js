/**
 * Batch Processing Template Structure
 *
 * This file contains the skeleton structure for batch TypeScript/JavaScript
 * AST extraction. It defines the main() function, batch request processing,
 * error handling, and result aggregation.
 *
 * Architecture:
 * - Extracted from: js_helper_templates.py.bak2 (Python constants)
 * - Used by: Python orchestrator to build final batch scripts
 * - Injected modules: core_extractors.js, cfg_extractor.js
 *
 * Structure:
 * - ES Module variant (lines ~14-354)
 * - CommonJS variant (lines ~357-666)
 *
 * The Python orchestrator will:
 * 1. Load this file
 * 2. Split on "// === COMMONJS_BATCH ===" separator
 * 3. Inject CORE_EXTRACTORS and CFG_EXTRACTOR into each template
 * 4. Return assembled batch script to subprocess
 *
 * NOTE: All f-string placeholders ({EXTRACT_*}) have been removed during
 * extraction. The new architecture prepends functions instead of injecting them.
 *
 * DO NOT EDIT THIS FILE HEADER - It is generated during refactoring.
 * The templates below are extracted 1:1 from the original Python file.
 */

// === ES_MODULE_BATCH ===

// ES Module helper script for batch TypeScript AST extraction
import path from 'path';
import fs from 'fs';
import { fileURLToPath, pathToFileURL } from 'url';

// ES modules don't have __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function findNearestTsconfig(startPath, projectRoot, ts, path) {
    let currentDir = path.resolve(path.dirname(startPath));
    const projectRootResolved = path.resolve(projectRoot);

    while (true) {
        const candidate = path.join(currentDir, 'tsconfig.json');
        if (ts.sys.fileExists(candidate)) {
            return candidate;
        }
        if (currentDir === projectRootResolved || currentDir === path.dirname(currentDir)) {
            break;
        }
        currentDir = path.dirname(currentDir);
    }

    return null;
}

async function main() {
    try {
        // Get request and output paths from command line
        const requestPath = process.argv[2];
        const outputPath = process.argv[3];

        if (!requestPath || !outputPath) {
            console.error(JSON.stringify({ error: "Request and output paths required" }));
            process.exit(1);
        }

        // Read batch request
        const request = JSON.parse(fs.readFileSync(requestPath, 'utf8'));
        const filePaths = request.files || [];
        const projectRoot = request.projectRoot;
        const jsxMode = request.jsxMode || 'transformed';  // Default to transformed for backward compatibility
        // PHASE 5: No more cfgOnly flag - single-pass extraction includes CFG

        if (filePaths.length === 0) {
            fs.writeFileSync(outputPath, JSON.stringify({}, 'utf8'));
            process.exit(0);
        }

        if (!projectRoot) {
            throw new Error("projectRoot not provided in batch request");
        }

        // Load TypeScript
        const tsPath = path.join(projectRoot, '.auditor_venv', '.theauditor_tools', 'node_modules', 'typescript', 'lib', 'typescript.js');

        if (!fs.existsSync(tsPath)) {
            throw new Error(`TypeScript not found at: ${tsPath}`);
        }

        const tsModule = await import(pathToFileURL(tsPath));
        const ts = tsModule.default || tsModule;

        const configMap = request.configMap || {};
        const resolvedProjectRoot = path.resolve(projectRoot);

        const normalizedConfigMap = new Map();
        for (const [key, value] of Object.entries(configMap)) {
            const resolvedKey = path.resolve(key);
            normalizedConfigMap.set(resolvedKey, value ? path.resolve(value) : null);
        }

        const filesByConfig = new Map();
        const DEFAULT_KEY = '__DEFAULT__';

        for (const filePath of filePaths) {
            const absoluteFilePath = path.resolve(filePath);
            const mappedConfig = normalizedConfigMap.get(absoluteFilePath);
            const nearestConfig = mappedConfig || findNearestTsconfig(absoluteFilePath, resolvedProjectRoot, ts, path);
            const groupKey = nearestConfig ? path.resolve(nearestConfig) : DEFAULT_KEY;

            if (!filesByConfig.has(groupKey)) {
                filesByConfig.set(groupKey, []);
            }
            filesByConfig.get(groupKey).push({ original: filePath, absolute: absoluteFilePath });
        }

        const results = {};
        const jsxEmitMode = jsxMode === 'preserved' ? ts.JsxEmit.Preserve : ts.JsxEmit.React;

        // DEBUG: Log batch mode info (PHASE 5: single-pass architecture)
        console.error(`[BATCH DEBUG] Processing ${filePaths.length} files, jsxMode=${jsxMode}, jsxEmitMode=${ts.JsxEmit[jsxEmitMode]}`);

        for (const [configKey, groupedFiles] of filesByConfig.entries()) {
            const configLabel = configKey === '__DEFAULT__' ? 'DEFAULT' : configKey;
            console.error(`[BATCH DEBUG] Config group: ${configLabel}, files=${groupedFiles.length}`);
            let compilerOptions;
            let program;

            if (configKey !== DEFAULT_KEY) {
                const tsConfig = ts.readConfigFile(configKey, ts.sys.readFile);
                if (tsConfig.error) {
                    throw new Error(`Failed to read tsconfig: ${ts.flattenDiagnosticMessageText(tsConfig.error.messageText, '\n')}`);
                }

                const configDir = path.dirname(configKey);
                const parsedConfig = ts.parseJsonConfigFileContent(
                    tsConfig.config,
                    ts.sys,
                    configDir,
                    {},
                    configKey
                );

                if (parsedConfig.errors && parsedConfig.errors.length > 0) {
                    const errorMessages = parsedConfig.errors
                        .map(err => ts.flattenDiagnosticMessageText(err.messageText, '\n'))
                        .join('; ');
                    throw new Error(`Failed to parse tsconfig: ${errorMessages}`);
                }

        compilerOptions = Object.assign({}, parsedConfig.options);
        compilerOptions.jsx = jsxEmitMode;
        const hasJavaScriptFiles = groupedFiles.some(fileInfo => {
            const ext = path.extname(fileInfo.absolute).toLowerCase();
            return ext === '.js' || ext === '.jsx' || ext === '.cjs' || ext === '.mjs';
        });
        if (hasJavaScriptFiles) {
            compilerOptions.allowJs = true;
            if (compilerOptions.checkJs === undefined) {
                compilerOptions.checkJs = false;
            }
        }
        const projectReferences = parsedConfig.projectReferences || [];
        program = ts.createProgram(
            groupedFiles.map(f => f.absolute),
            compilerOptions,
            undefined,
                    undefined,
                    undefined,
                    projectReferences
                );
            } else {
                compilerOptions = {
                    target: ts.ScriptTarget.Latest,
                    module: ts.ModuleKind.ESNext,
                    jsx: jsxEmitMode,
                    allowJs: true,
                    checkJs: false,
                    noEmit: true,
                    skipLibCheck: true,
                    moduleResolution: ts.ModuleResolutionKind.NodeJs,
                    baseUrl: resolvedProjectRoot,
                    rootDir: resolvedProjectRoot
                };
                program = ts.createProgram(
                    groupedFiles.map(f => f.absolute),
                    compilerOptions
                );
            }

            console.error(`[BATCH DEBUG] Created program, rootNames=${program.getRootFileNames().length}`);
            const checker = program.getTypeChecker();

            for (const fileInfo of groupedFiles) {
                try {
                    const sourceFile = program.getSourceFile(fileInfo.absolute);
                    if (!sourceFile) {
                        console.error(`[DEBUG JS BATCH] Could not load sourceFile for ${fileInfo.original}, jsxMode=${jsxMode}`);
                        results[fileInfo.original] = {
                            success: false,
                            error: `Could not load source file: ${fileInfo.original}`,
                            ast: null,
                            diagnostics: [],
                            symbols: []
                        };
                        continue;
                    }
                    console.error(`[DEBUG JS BATCH] Loaded sourceFile for ${fileInfo.original}, jsxMode=${jsxMode}`);

                    const sourceCode = sourceFile.text;

                    const diagnostics = [];
                    const fileDiagnostics = ts.getPreEmitDiagnostics(program, sourceFile);
                    fileDiagnostics.forEach(diagnostic => {
                        const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
                        const location = diagnostic.file && diagnostic.start
                            ? diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start)
                            : null;

                        diagnostics.push({
                            message,
                            category: ts.DiagnosticCategory[diagnostic.category],
                            code: diagnostic.code,
                            line: location ? location.line + 1 : null,
                            column: location ? location.character : null
                        });
                    });

                    const imports = extractImports(sourceFile, ts);

                    // PHASE 5: EXTRACTION-FIRST ARCHITECTURE (UNIFIED SINGLE-PASS)
                    // Extract ALL data types directly in JavaScript using TypeScript checker
                    // INCLUDES CFG EXTRACTION (fixes jsx='preserved' bug)
                    // No more two-pass system - everything extracted in one call

                    console.error(`[DEBUG JS BATCH] Single-pass extraction for ${fileInfo.original}, jsxMode=${jsxMode}`);

                    // Step 1: Build scope map (line → function name mapping)
                    const scopeMap = buildScopeMap(sourceFile, ts);

                    // Step 2: Extract functions and build parameter map
                    const functions = extractFunctions(sourceFile, checker, ts);
                    const functionParams = new Map();
                    functions.forEach(f => {
                        if (f.name && f.parameters) {
                            functionParams.set(f.name, f.parameters);
                        }
                    });

                    // Step 3: Extract all other data types
                    const calls = extractCalls(sourceFile, checker, ts, resolvedProjectRoot);
                    const classes = extractClasses(sourceFile, checker, ts);
                    const assignments = extractAssignments(sourceFile, ts, scopeMap);
                    const functionCallArgs = extractFunctionCallArgs(sourceFile, checker, ts, scopeMap, functionParams, resolvedProjectRoot);
                    const returns = extractReturns(sourceFile, ts, scopeMap);
                    const objectLiterals = extractObjectLiterals(sourceFile, ts, scopeMap);
                    const variableUsage = extractVariableUsage(assignments, functionCallArgs);
                    const importStyles = extractImportStyles(imports);
                    const refs = extractRefs(imports);
                    const reactComponents = extractReactComponents(functions, classes, returns, functionCallArgs);
                    const reactHooks = extractReactHooks(functionCallArgs, scopeMap);
                    const ormQueries = extractORMQueries(functionCallArgs);
                    const apiEndpoints = extractAPIEndpoints(functionCallArgs);

                    // Step 4: Extract CFG (NEW - fixes jsx='preserved' 0 CFG bug)
                    // CRITICAL: Skip CFG extraction for jsx='preserved' to prevent double extraction
                    // The 'preserved' batch is for JSX-specific symbol extraction only
                    let cfg = [];
                    if (jsxMode !== 'preserved') {
                        console.error(`[DEBUG JS BATCH] Extracting CFG for ${fileInfo.original} (jsxMode=${jsxMode})`);
                        cfg = extractCFG(sourceFile, ts);
                        console.error(`[DEBUG JS BATCH] Extracted ${cfg.length} CFGs from ${fileInfo.original}`);
                    } else {
                        console.error(`[DEBUG JS BATCH] Skipping CFG for ${fileInfo.original} (jsxMode=preserved, CFG already extracted in first batch)`);
                    }

                    // Count nodes for complexity metrics
                    const nodeCount = countNodes(sourceFile, ts);

                    results[fileInfo.original] = {
                        success: true,
                        fileName: fileInfo.absolute,
                        languageVersion: ts.ScriptTarget[sourceFile.languageVersion],
                        ast: null,  // ALWAYS null - no serialization, prevents 512MB crash
                        diagnostics: diagnostics,
                        imports: imports,
                        nodeCount: nodeCount,
                        hasTypes: true,
                        jsxMode: jsxMode,
                        extracted_data: {
                            // PHASE 5: All data types extracted in JavaScript (including CFG)
                            functions: functions,
                            classes: classes,
                            calls: calls,
                            imports: imports,
                            assignments: assignments,
                            function_call_args: functionCallArgs,
                            returns: returns,
                            object_literals: objectLiterals,
                            variable_usage: variableUsage,
                            import_styles: importStyles,
                            resolved_imports: refs,
                            react_components: reactComponents,
                            react_hooks: reactHooks,
                            orm_queries: ormQueries,
                            api_endpoints: apiEndpoints,
                            scope_map: Object.fromEntries(scopeMap),  // Convert Map to object for JSON
                            cfg: cfg  // CFG extracted in JavaScript (handles JSX nodes correctly)
                        }
                    };
                    console.error(`[DEBUG JS BATCH] Single-pass complete for ${fileInfo.original}, cfg_count=${cfg.length}`)

                } catch (error) {
                    results[fileInfo.original] = {
                        success: false,
                        error: `Error processing file: ${error.message}`,
                        ast: null,
                        diagnostics: [],
                        symbols: []
                    };
                }
            }
        }

        // Write all results
        fs.writeFileSync(outputPath, JSON.stringify(results, null, 2), 'utf8');
        process.exit(0);

    } catch (error) {
        console.error(JSON.stringify({
            success: false,
            error: error.message,
            stack: error.stack
        }));
        process.exit(1);
    }
}

// Run the async main function
main().catch(error => {
    console.error(JSON.stringify({
        success: false,
        error: `Unhandled error: ${error.message}`,
        stack: error.stack
    }));
    process.exit(1);
});

// === COMMONJS_BATCH ===

// CommonJS helper script for batch TypeScript AST extraction
const path = require('path');
const fs = require('fs');

function findNearestTsconfig(startPath, projectRoot, ts, path) {
    let currentDir = path.resolve(path.dirname(startPath));
    const projectRootResolved = path.resolve(projectRoot);

    while (true) {
        const candidate = path.join(currentDir, 'tsconfig.json');
        if (ts.sys.fileExists(candidate)) {
            return candidate;
        }
        if (currentDir === projectRootResolved || currentDir === path.dirname(currentDir)) {
            break;
        }
        currentDir = path.dirname(currentDir);
    }

    return null;
}

// Get request and output paths from command line
const requestPath = process.argv[2];
const outputPath = process.argv[3];

if (!requestPath || !outputPath) {
    console.error(JSON.stringify({ error: "Request and output paths required" }));
    process.exit(1);
}

try {
    // Read batch request
    const request = JSON.parse(fs.readFileSync(requestPath, 'utf8'));
    const filePaths = request.files || [];
    const projectRoot = request.projectRoot;
    const jsxMode = request.jsxMode || 'transformed';  // Default to transformed for backward compatibility
    // PHASE 5: No more cfgOnly flag - single-pass extraction includes CFG

    if (filePaths.length === 0) {
        fs.writeFileSync(outputPath, JSON.stringify({}, 'utf8'));
        process.exit(0);
    }

    if (!projectRoot) {
        throw new Error("projectRoot not provided in batch request");
    }

    // Load TypeScript
    const tsPath = path.join(projectRoot, '.auditor_venv', '.theauditor_tools', 'node_modules', 'typescript', 'lib', 'typescript.js');

    if (!fs.existsSync(tsPath)) {
        throw new Error(`TypeScript not found at: ${tsPath}`);
    }

    const ts = require(tsPath);

    // Find tsconfig.json if available
    const configMap = request.configMap || {};
    const resolvedProjectRoot = path.resolve(projectRoot);

    const normalizedConfigMap = new Map();
    Object.entries(configMap).forEach(([key, value]) => {
        const resolvedKey = path.resolve(key);
        normalizedConfigMap.set(resolvedKey, value ? path.resolve(value) : null);
    });

    const filesByConfig = new Map();
    const DEFAULT_KEY = '__DEFAULT__';

    for (const filePath of filePaths) {
        const absoluteFilePath = path.resolve(filePath);
        const mappedConfig = normalizedConfigMap.get(absoluteFilePath);
        const nearestConfig = mappedConfig || findNearestTsconfig(absoluteFilePath, resolvedProjectRoot, ts, path);
        const groupKey = nearestConfig ? path.resolve(nearestConfig) : DEFAULT_KEY;

        if (!filesByConfig.has(groupKey)) {
            filesByConfig.set(groupKey, []);
        }
        filesByConfig.get(groupKey).push({ original: filePath, absolute: absoluteFilePath });
    }

    const results = {};
    const jsxEmitMode = jsxMode === 'preserved' ? ts.JsxEmit.Preserve : ts.JsxEmit.React;

    for (const [configKey, groupedFiles] of filesByConfig.entries()) {
        let compilerOptions;
        let program;

        if (configKey !== DEFAULT_KEY) {
            const tsConfig = ts.readConfigFile(configKey, ts.sys.readFile);
            if (tsConfig.error) {
                throw new Error(`Failed to read tsconfig: ${ts.flattenDiagnosticMessageText(tsConfig.error.messageText, '\n')}`);
            }

            const configDir = path.dirname(configKey);
            const parsedConfig = ts.parseJsonConfigFileContent(
                tsConfig.config,
                ts.sys,
                configDir,
                {},
                configKey
            );

            if (parsedConfig.errors && parsedConfig.errors.length > 0) {
                const errorMessages = parsedConfig.errors
                    .map(err => ts.flattenDiagnosticMessageText(err.messageText, '\n'))
                    .join('; ');
                throw new Error(`Failed to parse tsconfig: ${errorMessages}`);
            }

                compilerOptions = Object.assign({}, parsedConfig.options);
                compilerOptions.jsx = jsxEmitMode;
                const hasJavaScriptFiles = groupedFiles.some(fileInfo => {
                    const ext = path.extname(fileInfo.absolute).toLowerCase();
                    return ext === '.js' || ext === '.jsx' || ext === '.cjs' || ext === '.mjs';
                });
                if (hasJavaScriptFiles) {
                    compilerOptions.allowJs = true;
                    if (compilerOptions.checkJs === undefined) {
                        compilerOptions.checkJs = false;
                    }
                }
                const projectReferences = parsedConfig.projectReferences || [];
                program = ts.createProgram(
                    groupedFiles.map(f => f.absolute),
                    compilerOptions,
                    undefined,
                undefined,
                undefined,
                projectReferences
            );
        } else {
            compilerOptions = {
                target: ts.ScriptTarget.Latest,
                module: ts.ModuleKind.ESNext,
                jsx: jsxEmitMode,
                allowJs: true,
                checkJs: false,
                noEmit: true,
                skipLibCheck: true,
                moduleResolution: ts.ModuleResolutionKind.NodeJs,
                baseUrl: resolvedProjectRoot,
                rootDir: resolvedProjectRoot
            };
            program = ts.createProgram(
                groupedFiles.map(f => f.absolute),
                compilerOptions
            );
        }

        const checker = program.getTypeChecker();

        for (const fileInfo of groupedFiles) {
            try {
                const sourceFile = program.getSourceFile(fileInfo.absolute);
                if (!sourceFile) {
                    results[fileInfo.original] = {
                        success: false,
                        error: `Could not load source file: ${fileInfo.original}`,
                        ast: null,
                        diagnostics: [],
                        symbols: []
                    };
                    continue;
                }

                const sourceCode = sourceFile.text;

                const diagnostics = [];
                const fileDiagnostics = ts.getPreEmitDiagnostics(program, sourceFile);
                fileDiagnostics.forEach(diagnostic => {
                    const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
                    const location = diagnostic.file && diagnostic.start
                        ? diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start)
                        : null;

                    diagnostics.push({
                        message,
                        category: ts.DiagnosticCategory[diagnostic.category],
                        code: diagnostic.code,
                        line: location ? location.line + 1 : null,
                        column: location ? location.character : null
                    });
                });

                const imports = extractImports(sourceFile, ts);

                // PHASE 5: EXTRACTION-FIRST ARCHITECTURE (UNIFIED SINGLE-PASS)
                // Extract ALL data types directly in JavaScript using TypeScript checker
                // INCLUDES CFG EXTRACTION (fixes jsx='preserved' bug)
                // No more two-pass system - everything extracted in one call

                // Step 1: Build scope map (line → function name mapping)
                const scopeMap = buildScopeMap(sourceFile, ts);

                // Step 2: Extract functions and build parameter map
                const functions = extractFunctions(sourceFile, checker, ts);
                const functionParams = new Map();
                functions.forEach(f => {
                    if (f.name && f.parameters) {
                        functionParams.set(f.name, f.parameters);
                    }
                });

                // Step 3: Extract all other data types
                const calls = extractCalls(sourceFile, checker, ts, resolvedProjectRoot);
                const classes = extractClasses(sourceFile, checker, ts);
                const assignments = extractAssignments(sourceFile, ts, scopeMap);
                const functionCallArgs = extractFunctionCallArgs(sourceFile, checker, ts, scopeMap, functionParams, resolvedProjectRoot);
                const returns = extractReturns(sourceFile, ts, scopeMap);
                const objectLiterals = extractObjectLiterals(sourceFile, ts, scopeMap);
                const variableUsage = extractVariableUsage(assignments, functionCallArgs);
                const importStyles = extractImportStyles(imports);
                const refs = extractRefs(imports);
                const reactComponents = extractReactComponents(functions, classes, returns, functionCallArgs);
                const reactHooks = extractReactHooks(functionCallArgs, scopeMap);
                const ormQueries = extractORMQueries(functionCallArgs);
                const apiEndpoints = extractAPIEndpoints(functionCallArgs);

                // Step 4: Extract CFG (NEW - fixes jsx='preserved' 0 CFG bug)
                // CRITICAL: Skip CFG extraction for jsx='preserved' to prevent double extraction
                // The 'preserved' batch is for JSX-specific symbol extraction only
                let cfg = [];
                if (jsxMode !== 'preserved') {
                    cfg = extractCFG(sourceFile, ts);
                } else {
                    // CFG already extracted in first batch, skip to avoid duplicates
                    cfg = [];
                }

                // Count nodes for complexity metrics
                const nodeCount = countNodes(sourceFile, ts);

                results[fileInfo.original] = {
                    success: true,
                    fileName: fileInfo.absolute,
                    languageVersion: ts.ScriptTarget[sourceFile.languageVersion],
                    ast: null,  // ALWAYS null - no serialization, prevents 512MB crash
                    diagnostics: diagnostics,
                    imports: imports,
                    nodeCount: nodeCount,
                    hasTypes: true,
                    jsxMode: jsxMode,
                    extracted_data: {
                        // PHASE 5: All data types extracted in JavaScript (including CFG)
                        functions: functions,
                        classes: classes,
                        calls: calls,
                        imports: imports,
                        assignments: assignments,
                        function_call_args: functionCallArgs,
                        returns: returns,
                        object_literals: objectLiterals,
                        variable_usage: variableUsage,
                        import_styles: importStyles,
                        resolved_imports: refs,
                        react_components: reactComponents,
                        react_hooks: reactHooks,
                        orm_queries: ormQueries,
                        api_endpoints: apiEndpoints,
                        scope_map: Object.fromEntries(scopeMap),  // Convert Map to object for JSON
                        cfg: cfg  // CFG extracted in JavaScript (handles JSX nodes correctly)
                    }
                }

            } catch (error) {
                results[fileInfo.original] = {
                    success: false,
                    error: `Error processing file: ${error.message}`,
                    ast: null,
                    diagnostics: [],
                    symbols: []
                };
            }
        }
    }
    // Write all results
    fs.writeFileSync(outputPath, JSON.stringify(results, null, 2), 'utf8');
    process.exit(0);

} catch (error) {
    console.error(JSON.stringify({
        success: false,
        error: error.message,
        stack: error.stack
    }));
    process.exit(1);
}
