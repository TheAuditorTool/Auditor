/**
 * Batch Processing Template Structure
 *
 * This file contains the skeleton structure for batch TypeScript/JavaScript
 * AST extraction. It defines the main() function, batch request processing,
 * error handling, and result aggregation.
 *
 * Architecture:
 * - Extracted from: js_helper_templates.py.bak2 (Python constants)
 * - Used by: Python orchestrator to build final batch scripts
 * - Injected modules: core_extractors.js, cfg_extractor.js
 *
 * Structure:
 * - ES Module variant (lines ~14-354)
 * - CommonJS variant (lines ~357-666)
 *
 * The Python orchestrator will:
 * 1. Load this file
 * 2. Split on "// === COMMONJS_BATCH ===" separator
 * 3. Inject CORE_EXTRACTORS and CFG_EXTRACTOR into each template
 * 4. Return assembled batch script to subprocess
 *
 * NOTE: All f-string placeholders ({EXTRACT_*}) have been removed during
 * extraction. The new architecture prepends functions instead of injecting them.
 *
 * DO NOT EDIT THIS FILE HEADER - It is generated during refactoring.
 * The templates below are extracted 1:1 from the original Python file.
 */

// === ES_MODULE_BATCH ===

// ES Module helper script for batch TypeScript AST extraction
import path from 'path';
import fs from 'fs';
import os from 'os';
import crypto from 'crypto';
import { fileURLToPath, pathToFileURL } from 'url';
import { createRequire } from 'module';

const require = createRequire(import.meta.url);

let parseVueSfc = null;
let compileVueScript = null;
let compileVueTemplate = null;
let VueNodeTypes = null;

try {
    const vueSfcModule = require('@vue/compiler-sfc');
    if (vueSfcModule) {
        parseVueSfc = vueSfcModule.parse;
        compileVueScript = vueSfcModule.compileScript;
        compileVueTemplate = vueSfcModule.compileTemplate;
    }
} catch (err) {
    console.error(`[VUE SUPPORT DISABLED] @vue/compiler-sfc not available: ${err.message}`);
}

try {
    const vueDomModule = require('@vue/compiler-dom');
    if (vueDomModule) {
        VueNodeTypes = vueDomModule.NodeTypes;
    }
} catch (err) {
    console.error(`[VUE TEMPLATE SUPPORT DISABLED] @vue/compiler-dom not available: ${err.message}`);
}

// ES modules don't have __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function findNearestTsconfig(startPath, projectRoot, ts, path) {
    let currentDir = path.resolve(path.dirname(startPath));
    const projectRootResolved = path.resolve(projectRoot);

    while (true) {
        const candidate = path.join(currentDir, 'tsconfig.json');
        if (ts.sys.fileExists(candidate)) {
            return candidate;
        }
        if (currentDir === projectRootResolved || currentDir === path.dirname(currentDir)) {
            break;
        }
        currentDir = path.dirname(currentDir);
    }

    return null;
}

function createVueScopeId(filePath) {
    return crypto.createHash('sha256').update(filePath).digest('hex').slice(0, 8);
}

function createVueTempPath(scopeId, langHint) {
    const isTs = langHint && langHint.toLowerCase().includes('ts');
    const ext = isTs ? '.ts' : '.js';
    const randomPart = crypto.randomBytes(4).toString('hex');
    return path.join(os.tmpdir(), `theauditor_vue_${scopeId}_${Date.now()}_${randomPart}${ext}`);
}

function safeUnlink(filePath) {
    if (!filePath) {
        return;
    }
    try {
        if (fs.existsSync(filePath)) {
            fs.unlinkSync(filePath);
        }
    } catch (err) {
        console.error(`[VUE TEMP CLEANUP] Failed to remove ${filePath}: ${err.message}`);
    }
}

function ensureVueCompilerAvailable() {
    if (!parseVueSfc || !compileVueScript) {
        throw new Error('Vue SFC support requires @vue/compiler-sfc. Install dependency or skip .vue files.');
    }
}

function prepareVueSfcFile(filePath) {
    ensureVueCompilerAvailable();

    const source = fs.readFileSync(filePath, 'utf8');
    const { descriptor, errors } = parseVueSfc(source, { filename: filePath });

    if (errors && errors.length > 0) {
        const firstError = errors[0];
        const message = typeof firstError === 'string'
            ? firstError
            : firstError.message || firstError.msg || 'Unknown Vue SFC parse error';
        throw new Error(message);
    }

    if (!descriptor.script && !descriptor.scriptSetup) {
        throw new Error('Vue SFC is missing <script> or <script setup> block');
    }

    const scopeId = createVueScopeId(filePath);
    let compiledScript;
    try {
        compiledScript = compileVueScript(descriptor, { id: scopeId, inlineTemplate: false });
    } catch (err) {
        throw new Error(`Failed to compile Vue script: ${err.message}`);
    }

    const langHint = (descriptor.scriptSetup && descriptor.scriptSetup.lang) || (descriptor.script && descriptor.script.lang) || 'js';
    const tempFilePath = createVueTempPath(scopeId, langHint || 'js');
    fs.writeFileSync(tempFilePath, compiledScript.content, 'utf8');

    let templateAst = null;
    if (descriptor.template && descriptor.template.content) {
        if (typeof compileVueTemplate === 'function') {
            try {
                const templateResult = compileVueTemplate({
                    source: descriptor.template.content,
                    filename: filePath,
                    id: scopeId
                });
                templateAst = templateResult.ast || null;
            } catch (err) {
                console.error(`[VUE TEMPLATE WARN] Failed to compile template for ${filePath}: ${err.message}`);
            }
        } else {
            console.error(`[VUE TEMPLATE WARN] Template compilation skipped for ${filePath}: @vue/compiler-sfc missing compileTemplate export`);
        }
    }

    return {
        tempFilePath,
        descriptor,
        compiledScript,
        templateAst,
        scopeId,
        hasStyle: descriptor.styles && descriptor.styles.length > 0
    };
}

async function main() {
    try {
        // Get request and output paths from command line
        const requestPath = process.argv[2];
        const outputPath = process.argv[3];

        if (!requestPath || !outputPath) {
            console.error(JSON.stringify({ error: "Request and output paths required" }));
            process.exit(1);
        }

        // Read batch request
        const request = JSON.parse(fs.readFileSync(requestPath, 'utf8'));
        const filePaths = request.files || [];
        const projectRoot = request.projectRoot;
        const jsxMode = request.jsxMode || 'transformed';  // Default to transformed for backward compatibility
        // PHASE 5: No more cfgOnly flag - single-pass extraction includes CFG

        if (filePaths.length === 0) {
            fs.writeFileSync(outputPath, JSON.stringify({}, 'utf8'));
            process.exit(0);
        }

        if (!projectRoot) {
            throw new Error("projectRoot not provided in batch request");
        }

        // Load TypeScript
        const tsPath = path.join(projectRoot, '.auditor_venv', '.theauditor_tools', 'node_modules', 'typescript', 'lib', 'typescript.js');

        if (!fs.existsSync(tsPath)) {
            throw new Error(`TypeScript not found at: ${tsPath}`);
        }

        const tsModule = await import(pathToFileURL(tsPath));
        const ts = tsModule.default || tsModule;

        const configMap = request.configMap || {};
        const resolvedProjectRoot = path.resolve(projectRoot);

        const normalizedConfigMap = new Map();
        for (const [key, value] of Object.entries(configMap)) {
            const resolvedKey = path.resolve(key);
            normalizedConfigMap.set(resolvedKey, value ? path.resolve(value) : null);
        }

        const filesByConfig = new Map();
        const DEFAULT_KEY = '__DEFAULT__';
        const preprocessingErrors = new Map();

        for (const filePath of filePaths) {
            const absoluteFilePath = path.resolve(filePath);
            const ext = path.extname(absoluteFilePath).toLowerCase();
            const fileEntry = {
                original: filePath,
                absolute: absoluteFilePath,
                cleanup: null,
                vueMeta: null
            };

            if (ext === '.vue') {
                try {
                    const vueMeta = prepareVueSfcFile(absoluteFilePath);
                    fileEntry.absolute = vueMeta.tempFilePath;
                    fileEntry.cleanup = vueMeta.tempFilePath;
                    fileEntry.vueMeta = vueMeta;
                } catch (err) {
                    preprocessingErrors.set(filePath, `Vue SFC preprocessing failed: ${err.message}`);
                    continue;
                }
            }

            const mappedConfig = normalizedConfigMap.get(absoluteFilePath);
            const nearestConfig = mappedConfig || findNearestTsconfig(absoluteFilePath, resolvedProjectRoot, ts, path);
            const groupKey = nearestConfig ? path.resolve(nearestConfig) : DEFAULT_KEY;

            if (!filesByConfig.has(groupKey)) {
                filesByConfig.set(groupKey, []);
            }
            filesByConfig.get(groupKey).push(fileEntry);
        }

        const results = {};
        const jsxEmitMode = jsxMode === 'preserved' ? ts.JsxEmit.Preserve : ts.JsxEmit.React;

        // DEBUG: Log batch mode info (PHASE 5: single-pass architecture)
        console.error(`[BATCH DEBUG] Processing ${filePaths.length} files, jsxMode=${jsxMode}, jsxEmitMode=${ts.JsxEmit[jsxEmitMode]}`);

        for (const [configKey, groupedFiles] of filesByConfig.entries()) {
            const configLabel = configKey === '__DEFAULT__' ? 'DEFAULT' : configKey;
            console.error(`[BATCH DEBUG] Config group: ${configLabel}, files=${groupedFiles.length}`);
            if (!groupedFiles || groupedFiles.length === 0) {
                continue;
            }
            let compilerOptions;
            let program;

            if (configKey !== DEFAULT_KEY) {
                const tsConfig = ts.readConfigFile(configKey, ts.sys.readFile);
                if (tsConfig.error) {
                    throw new Error(`Failed to read tsconfig: ${ts.flattenDiagnosticMessageText(tsConfig.error.messageText, '\n')}`);
                }

                const configDir = path.dirname(configKey);
                const parsedConfig = ts.parseJsonConfigFileContent(
                    tsConfig.config,
                    ts.sys,
                    configDir,
                    {},
                    configKey
                );

                if (parsedConfig.errors && parsedConfig.errors.length > 0) {
                    const errorMessages = parsedConfig.errors
                        .map(err => ts.flattenDiagnosticMessageText(err.messageText, '\n'))
                        .join('; ');
                    throw new Error(`Failed to parse tsconfig: ${errorMessages}`);
                }

        compilerOptions = Object.assign({}, parsedConfig.options);
        compilerOptions.jsx = jsxEmitMode;
        const hasJavaScriptFiles = groupedFiles.some(fileInfo => {
            const ext = path.extname(fileInfo.absolute).toLowerCase();
            return ext === '.js' || ext === '.jsx' || ext === '.cjs' || ext === '.mjs';
        });
        if (hasJavaScriptFiles) {
            compilerOptions.allowJs = true;
            if (compilerOptions.checkJs === undefined) {
                compilerOptions.checkJs = false;
            }
        }
        const projectReferences = parsedConfig.projectReferences || [];
        program = ts.createProgram(
            groupedFiles.map(f => f.absolute),
            compilerOptions,
            undefined,
                    undefined,
                    undefined,
                    projectReferences
                );
            } else {
                compilerOptions = {
                    target: ts.ScriptTarget.Latest,
                    module: ts.ModuleKind.ESNext,
                    jsx: jsxEmitMode,
                    allowJs: true,
                    checkJs: false,
                    noEmit: true,
                    skipLibCheck: true,
                    moduleResolution: ts.ModuleResolutionKind.NodeJs,
                    baseUrl: resolvedProjectRoot,
                    rootDir: resolvedProjectRoot
                };
                program = ts.createProgram(
                    groupedFiles.map(f => f.absolute),
                    compilerOptions
                );
            }

            console.error(`[BATCH DEBUG] Created program, rootNames=${program.getRootFileNames().length}`);
            const checker = program.getTypeChecker();

            for (const fileInfo of groupedFiles) {
                try {
                    const sourceFile = program.getSourceFile(fileInfo.absolute);
                    if (!sourceFile) {
                        console.error(`[DEBUG JS BATCH] Could not load sourceFile for ${fileInfo.original}, jsxMode=${jsxMode}`);
                        results[fileInfo.original] = {
                            success: false,
                            error: `Could not load source file: ${fileInfo.original}`,
                            ast: null,
                            diagnostics: [],
                            symbols: []
                        };
                        continue;
                    }
                    console.error(`[DEBUG JS BATCH] Loaded sourceFile for ${fileInfo.original}, jsxMode=${jsxMode}`);

                    const sourceCode = sourceFile.text;

                    const diagnostics = [];
                    const fileDiagnostics = ts.getPreEmitDiagnostics(program, sourceFile);
                    fileDiagnostics.forEach(diagnostic => {
                        const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
                        const location = diagnostic.file && diagnostic.start
                            ? diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start)
                            : null;

                        diagnostics.push({
                            message,
                            category: ts.DiagnosticCategory[diagnostic.category],
                            code: diagnostic.code,
                            line: location ? location.line + 1 : null,
                            column: location ? location.character : null
                        });
                    });

                    const imports = extractImports(sourceFile, ts);

                    // PHASE 5: EXTRACTION-FIRST ARCHITECTURE (UNIFIED SINGLE-PASS)
                    // Extract ALL data types directly in JavaScript using TypeScript checker
                    // INCLUDES CFG EXTRACTION (fixes jsx='preserved' bug)
                    // No more two-pass system - everything extracted in one call

                    console.error(`[DEBUG JS BATCH] Single-pass extraction for ${fileInfo.original}, jsxMode=${jsxMode}`);

                    // Step 1: Build scope map (line → function name mapping)
                    const scopeMap = buildScopeMap(sourceFile, ts);

                    // Step 2: Extract functions and build parameter map
                    const functions = extractFunctions(sourceFile, checker, ts);
                    const functionParams = new Map();
                    functions.forEach(f => {
                        if (f.name && f.parameters) {
                            functionParams.set(f.name, f.parameters);
                        }
                    });

                    // Step 3: Extract all other data types
                    const calls = extractCalls(sourceFile, checker, ts, resolvedProjectRoot);
                    const classes = extractClasses(sourceFile, checker, ts);
                    const classProperties = extractClassProperties(sourceFile, ts);
                    console.error(`[DEBUG JS BATCH] Extracted ${classProperties.length} class properties from ${fileInfo.original}`);
                    const envVarUsage = extractEnvVarUsage(sourceFile, ts, scopeMap);
                    const ormRelationships = extractORMRelationships(sourceFile, ts);
                    const assignments = extractAssignments(sourceFile, ts, scopeMap);
                    const functionCallArgs = extractFunctionCallArgs(sourceFile, checker, ts, scopeMap, functionParams, resolvedProjectRoot);
                    const returns = extractReturns(sourceFile, ts, scopeMap);
                    const objectLiterals = extractObjectLiterals(sourceFile, ts, scopeMap);
                    const variableUsage = extractVariableUsage(assignments, functionCallArgs);
                    const importStyles = extractImportStyles(imports);
                    const refs = extractRefs(imports);
                    const reactComponents = extractReactComponents(functions, classes, returns, functionCallArgs, fileInfo.original);
                    const reactHooks = extractReactHooks(functionCallArgs, scopeMap);
                    const ormQueries = extractORMQueries(functionCallArgs);
                    const apiEndpoints = extractAPIEndpoints(functionCallArgs);
                    const validationUsage = extractValidationFrameworkUsage(functionCallArgs, assignments, imports);
                    const sqlQueries = extractSQLQueries(functionCallArgs);

                    let vueComponents = [];
                    let vueHooks = [];
                    let vueDirectives = [];
                    let vueProvideInject = [];

                    if (fileInfo.vueMeta) {
                        const vueComponentData = extractVueComponents(
                            fileInfo.vueMeta,
                            fileInfo.original,
                            functionCallArgs,
                            returns
                        );
                        vueComponents = vueComponentData.components;
                        const activeComponentName = vueComponentData.primaryName;
                        vueHooks = extractVueHooks(functionCallArgs, activeComponentName);
                        vueProvideInject = extractVueProvideInject(functionCallArgs, activeComponentName);
                        vueDirectives = extractVueDirectives(fileInfo.vueMeta.templateAst, activeComponentName, VueNodeTypes);
                    }

                    // Step 4: Extract CFG (NEW - fixes jsx='preserved' 0 CFG bug)
                    // CRITICAL: Skip CFG extraction for jsx='preserved' to prevent double extraction
                    // The 'preserved' batch is for JSX-specific symbol extraction only
                    let cfg = [];
                    if (jsxMode !== 'preserved') {
                        console.error(`[DEBUG JS BATCH] Extracting CFG for ${fileInfo.original} (jsxMode=${jsxMode})`);
                        cfg = extractCFG(sourceFile, ts);
                        console.error(`[DEBUG JS BATCH] Extracted ${cfg.length} CFGs from ${fileInfo.original}`);
                    } else {
                        console.error(`[DEBUG JS BATCH] Skipping CFG for ${fileInfo.original} (jsxMode=preserved, CFG already extracted in first batch)`);
                    }

                    // Count nodes for complexity metrics
                    const nodeCount = countNodes(sourceFile, ts);

                    results[fileInfo.original] = {
                        success: true,
                        fileName: fileInfo.absolute,
                        languageVersion: ts.ScriptTarget[sourceFile.languageVersion],
                        ast: null,  // ALWAYS null - no serialization, prevents 512MB crash
                        diagnostics: diagnostics,
                        imports: imports,
                        nodeCount: nodeCount,
                        hasTypes: true,
                        jsxMode: jsxMode,
                        extracted_data: {
                            // PHASE 5: All data types extracted in JavaScript (including CFG)
                            functions: functions,
                            classes: classes,
                            class_properties: classProperties,
                            env_var_usage: envVarUsage,
                            orm_relationships: ormRelationships,
                            calls: calls,
                            imports: imports,
                            assignments: assignments,
                            function_call_args: functionCallArgs,
                            returns: returns,
                            object_literals: objectLiterals,
                            variable_usage: variableUsage,
                            import_styles: importStyles,
                            resolved_imports: refs,
                            react_components: reactComponents,
                            react_hooks: reactHooks,
                            orm_queries: ormQueries,
                            routes: apiEndpoints,  // FIX: Renamed 'api_endpoints' to 'routes' to match Python indexer
                            validation_framework_usage: validationUsage,
                            sql_queries: sqlQueries,
                            vue_components: vueComponents,
                            vue_hooks: vueHooks,
                            vue_directives: vueDirectives,
                            vue_provide_inject: vueProvideInject,
                            scope_map: Object.fromEntries(scopeMap),  // Convert Map to object for JSON
                            cfg: cfg  // CFG extracted in JavaScript (handles JSX nodes correctly)
                        }
                    };
                    console.error(`[DEBUG JS BATCH] Single-pass complete for ${fileInfo.original}, cfg_count=${cfg.length}`)

                } catch (error) {
                    results[fileInfo.original] = {
                        success: false,
                        error: `Error processing file: ${error.message}`,
                        ast: null,
                        diagnostics: [],
                        symbols: []
                    };
                } finally {
                    if (fileInfo.cleanup) {
                        safeUnlink(fileInfo.cleanup);
                    }
                }
            }
        }

        for (const [failedPath, message] of preprocessingErrors.entries()) {
            results[failedPath] = {
                success: false,
                error: message,
                ast: null,
                diagnostics: [],
                symbols: []
            };
        }

        // Write all results
        fs.writeFileSync(outputPath, JSON.stringify(results, null, 2), 'utf8');
        process.exit(0);

    } catch (error) {
        console.error(JSON.stringify({
            success: false,
            error: error.message,
            stack: error.stack
        }));
        process.exit(1);
    }
}

// Run the async main function
main().catch(error => {
    console.error(JSON.stringify({
        success: false,
        error: `Unhandled error: ${error.message}`,
        stack: error.stack
    }));
    process.exit(1);
});

// === COMMONJS_BATCH ===

// CommonJS helper script for batch TypeScript AST extraction
const path = require('path');
const fs = require('fs');
const os = require('os');
const crypto = require('crypto');

let parseVueSfc = null;
let compileVueScript = null;
let compileVueTemplate = null;
let VueNodeTypes = null;

try {
    const vueSfcModule = require('@vue/compiler-sfc');
    if (vueSfcModule) {
        parseVueSfc = vueSfcModule.parse;
        compileVueScript = vueSfcModule.compileScript;
        compileVueTemplate = vueSfcModule.compileTemplate;
    }
} catch (err) {
    console.error(`[VUE SUPPORT DISABLED] @vue/compiler-sfc not available: ${err.message}`);
}

try {
    const vueDomModule = require('@vue/compiler-dom');
    if (vueDomModule) {
        VueNodeTypes = vueDomModule.NodeTypes;
    }
} catch (err) {
    console.error(`[VUE TEMPLATE SUPPORT DISABLED] @vue/compiler-dom not available: ${err.message}`);
}

function ensureVueCompilerAvailable() {
    if (!parseVueSfc || !compileVueScript) {
        throw new Error('Vue SFC support requires @vue/compiler-sfc. Install dependency or skip .vue files.');
    }
}

function createVueScopeId(filePath) {
    return crypto.createHash('sha256').update(filePath).digest('hex').slice(0, 8);
}

function createVueTempPath(scopeId, langHint) {
    const isTs = langHint && langHint.toLowerCase().includes('ts');
    const ext = isTs ? '.ts' : '.js';
    const randomPart = crypto.randomBytes(4).toString('hex');
    return path.join(os.tmpdir(), `theauditor_vue_${scopeId}_${Date.now()}_${randomPart}${ext}`);
}

function safeUnlink(filePath) {
    if (!filePath) {
        return;
    }
    try {
        if (fs.existsSync(filePath)) {
            fs.unlinkSync(filePath);
        }
    } catch (err) {
        console.error(`[VUE TEMP CLEANUP] Failed to remove ${filePath}: ${err.message}`);
    }
}

function prepareVueSfcFile(filePath) {
    ensureVueCompilerAvailable();

    const source = fs.readFileSync(filePath, 'utf8');
    const { descriptor, errors } = parseVueSfc(source, { filename: filePath });

    if (errors && errors.length > 0) {
        const firstError = errors[0];
        const message = typeof firstError === 'string'
            ? firstError
            : firstError.message || firstError.msg || 'Unknown Vue SFC parse error';
        throw new Error(message);
    }

    if (!descriptor.script && !descriptor.scriptSetup) {
        throw new Error('Vue SFC is missing <script> or <script setup> block');
    }

    const scopeId = createVueScopeId(filePath);
    let compiledScript;
    try {
        compiledScript = compileVueScript(descriptor, { id: scopeId, inlineTemplate: false });
    } catch (err) {
        throw new Error(`Failed to compile Vue script: ${err.message}`);
    }

    const langHint = (descriptor.scriptSetup && descriptor.scriptSetup.lang) || (descriptor.script && descriptor.script.lang) || 'js';
    const tempFilePath = createVueTempPath(scopeId, langHint || 'js');
    fs.writeFileSync(tempFilePath, compiledScript.content, 'utf8');

    let templateAst = null;
    if (descriptor.template && descriptor.template.content) {
        if (typeof compileVueTemplate === 'function') {
            try {
                const templateResult = compileVueTemplate({
                    source: descriptor.template.content,
                    filename: filePath,
                    id: scopeId
                });
                templateAst = templateResult.ast || null;
            } catch (err) {
                console.error(`[VUE TEMPLATE WARN] Failed to compile template for ${filePath}: ${err.message}`);
            }
        } else {
            console.error(`[VUE TEMPLATE WARN] Template compilation skipped for ${filePath}: @vue/compiler-sfc missing compileTemplate export`);
        }
    }

    return {
        tempFilePath,
        scopeId,
        descriptor,
        templateAst
    };
}

function findNearestTsconfig(startPath, projectRoot, ts, path) {
    let currentDir = path.resolve(path.dirname(startPath));
    const projectRootResolved = path.resolve(projectRoot);

    while (true) {
        const candidate = path.join(currentDir, 'tsconfig.json');
        if (ts.sys.fileExists(candidate)) {
            return candidate;
        }
        if (currentDir === projectRootResolved || currentDir === path.dirname(currentDir)) {
            break;
        }
        currentDir = path.dirname(currentDir);
    }

    return null;
}

// Get request and output paths from command line
const requestPath = process.argv[2];
const outputPath = process.argv[3];

if (!requestPath || !outputPath) {
    console.error(JSON.stringify({ error: "Request and output paths required" }));
    process.exit(1);
}

try {
    // Read batch request
    const request = JSON.parse(fs.readFileSync(requestPath, 'utf8'));
    const filePaths = request.files || [];
    const projectRoot = request.projectRoot;
    const jsxMode = request.jsxMode || 'transformed';  // Default to transformed for backward compatibility
    // PHASE 5: No more cfgOnly flag - single-pass extraction includes CFG

    if (filePaths.length === 0) {
        fs.writeFileSync(outputPath, JSON.stringify({}, 'utf8'));
        process.exit(0);
    }

    if (!projectRoot) {
        throw new Error("projectRoot not provided in batch request");
    }

    // Load TypeScript
    const tsPath = path.join(projectRoot, '.auditor_venv', '.theauditor_tools', 'node_modules', 'typescript', 'lib', 'typescript.js');

    if (!fs.existsSync(tsPath)) {
        throw new Error(`TypeScript not found at: ${tsPath}`);
    }

    const ts = require(tsPath);

    // Find tsconfig.json if available
    const configMap = request.configMap || {};
    const resolvedProjectRoot = path.resolve(projectRoot);

    const normalizedConfigMap = new Map();
    Object.entries(configMap).forEach(([key, value]) => {
        const resolvedKey = path.resolve(key);
        normalizedConfigMap.set(resolvedKey, value ? path.resolve(value) : null);
    });

    const filesByConfig = new Map();
    const DEFAULT_KEY = '__DEFAULT__';
    const preprocessingErrors = new Map();

    for (const filePath of filePaths) {
        const absoluteFilePath = path.resolve(filePath);
        const ext = path.extname(absoluteFilePath).toLowerCase();
        const fileEntry = {
            original: filePath,
            absolute: absoluteFilePath,
            cleanup: null,
            vueMeta: null
        };

        if (ext === '.vue') {
            try {
                const vueMeta = prepareVueSfcFile(absoluteFilePath);
                fileEntry.absolute = vueMeta.tempFilePath;
                fileEntry.cleanup = vueMeta.tempFilePath;
                fileEntry.vueMeta = vueMeta;
            } catch (err) {
                preprocessingErrors.set(filePath, `Vue SFC preprocessing failed: ${err.message}`);
                continue;
            }
        }

        const mappedConfig = normalizedConfigMap.get(absoluteFilePath);
        const nearestConfig = mappedConfig || findNearestTsconfig(absoluteFilePath, resolvedProjectRoot, ts, path);
        const groupKey = nearestConfig ? path.resolve(nearestConfig) : DEFAULT_KEY;

        if (!filesByConfig.has(groupKey)) {
            filesByConfig.set(groupKey, []);
        }
        filesByConfig.get(groupKey).push(fileEntry);
    }

    const results = {};
    const jsxEmitMode = jsxMode === 'preserved' ? ts.JsxEmit.Preserve : ts.JsxEmit.React;

    for (const [configKey, groupedFiles] of filesByConfig.entries()) {
        if (!groupedFiles || groupedFiles.length === 0) {
            continue;
        }
        let compilerOptions;
        let program;

        if (configKey !== DEFAULT_KEY) {
            const tsConfig = ts.readConfigFile(configKey, ts.sys.readFile);
            if (tsConfig.error) {
                throw new Error(`Failed to read tsconfig: ${ts.flattenDiagnosticMessageText(tsConfig.error.messageText, '\n')}`);
            }

            const configDir = path.dirname(configKey);
            const parsedConfig = ts.parseJsonConfigFileContent(
                tsConfig.config,
                ts.sys,
                configDir,
                {},
                configKey
            );

            if (parsedConfig.errors && parsedConfig.errors.length > 0) {
                const errorMessages = parsedConfig.errors
                    .map(err => ts.flattenDiagnosticMessageText(err.messageText, '\n'))
                    .join('; ');
                throw new Error(`Failed to parse tsconfig: ${errorMessages}`);
            }

                compilerOptions = Object.assign({}, parsedConfig.options);
                compilerOptions.jsx = jsxEmitMode;
                const hasJavaScriptFiles = groupedFiles.some(fileInfo => {
                    const ext = path.extname(fileInfo.absolute).toLowerCase();
                    return ext === '.js' || ext === '.jsx' || ext === '.cjs' || ext === '.mjs';
                });
                if (hasJavaScriptFiles) {
                    compilerOptions.allowJs = true;
                    if (compilerOptions.checkJs === undefined) {
                        compilerOptions.checkJs = false;
                    }
                }
                const projectReferences = parsedConfig.projectReferences || [];
                program = ts.createProgram(
                    groupedFiles.map(f => f.absolute),
                    compilerOptions,
                    undefined,
                undefined,
                undefined,
                projectReferences
            );
        } else {
            compilerOptions = {
                target: ts.ScriptTarget.Latest,
                module: ts.ModuleKind.ESNext,
                jsx: jsxEmitMode,
                allowJs: true,
                checkJs: false,
                noEmit: true,
                skipLibCheck: true,
                moduleResolution: ts.ModuleResolutionKind.NodeJs,
                baseUrl: resolvedProjectRoot,
                rootDir: resolvedProjectRoot
            };
            program = ts.createProgram(
                groupedFiles.map(f => f.absolute),
                compilerOptions
            );
        }

        const checker = program.getTypeChecker();

        for (const fileInfo of groupedFiles) {
            try {
                const sourceFile = program.getSourceFile(fileInfo.absolute);
                if (!sourceFile) {
                    results[fileInfo.original] = {
                        success: false,
                        error: `Could not load source file: ${fileInfo.original}`,
                        ast: null,
                        diagnostics: [],
                        symbols: []
                    };
                    continue;
                }

                const sourceCode = sourceFile.text;

                const diagnostics = [];
                const fileDiagnostics = ts.getPreEmitDiagnostics(program, sourceFile);
                fileDiagnostics.forEach(diagnostic => {
                    const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
                    const location = diagnostic.file && diagnostic.start
                        ? diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start)
                        : null;

                    diagnostics.push({
                        message,
                        category: ts.DiagnosticCategory[diagnostic.category],
                        code: diagnostic.code,
                        line: location ? location.line + 1 : null,
                        column: location ? location.character : null
                    });
                });

                const imports = extractImports(sourceFile, ts);

                // PHASE 5: EXTRACTION-FIRST ARCHITECTURE (UNIFIED SINGLE-PASS)
                // Extract ALL data types directly in JavaScript using TypeScript checker
                // INCLUDES CFG EXTRACTION (fixes jsx='preserved' bug)
                // No more two-pass system - everything extracted in one call

                // Step 1: Build scope map (line → function name mapping)
                const scopeMap = buildScopeMap(sourceFile, ts);

                // Step 2: Extract functions and build parameter map
                const functions = extractFunctions(sourceFile, checker, ts);
                const functionParams = new Map();
                functions.forEach(f => {
                    if (f.name && f.parameters) {
                        functionParams.set(f.name, f.parameters);
                    }
                });

                // Step 3: Extract all other data types
                const calls = extractCalls(sourceFile, checker, ts, resolvedProjectRoot);
                const classes = extractClasses(sourceFile, checker, ts);
                const classProperties = extractClassProperties(sourceFile, ts);
                console.error(`[DEBUG JS BATCH] Extracted ${classProperties.length} class properties from ${fileInfo.original}`);
                const envVarUsage = extractEnvVarUsage(sourceFile, ts, scopeMap);
                const ormRelationships = extractORMRelationships(sourceFile, ts);
                const assignments = extractAssignments(sourceFile, ts, scopeMap);
                const functionCallArgs = extractFunctionCallArgs(sourceFile, checker, ts, scopeMap, functionParams, resolvedProjectRoot);
                const returns = extractReturns(sourceFile, ts, scopeMap);
                const objectLiterals = extractObjectLiterals(sourceFile, ts, scopeMap);
                const variableUsage = extractVariableUsage(assignments, functionCallArgs);
                const importStyles = extractImportStyles(imports);
                const refs = extractRefs(imports);
                const reactComponents = extractReactComponents(functions, classes, returns, functionCallArgs, fileInfo.original);
                const reactHooks = extractReactHooks(functionCallArgs, scopeMap);
                const ormQueries = extractORMQueries(functionCallArgs);
                const apiEndpoints = extractAPIEndpoints(functionCallArgs);
                const validationUsage = extractValidationFrameworkUsage(functionCallArgs, assignments, imports);
                const sqlQueries = extractSQLQueries(functionCallArgs);

                let vueComponents = [];
                let vueHooks = [];
                let vueDirectives = [];
                let vueProvideInject = [];

                if (fileInfo.vueMeta) {
                    const vueComponentData = extractVueComponents(
                        fileInfo.vueMeta,
                        fileInfo.original,
                        functionCallArgs,
                        returns
                    );
                    vueComponents = vueComponentData.components;
                    const activeComponentName = vueComponentData.primaryName;
                    vueHooks = extractVueHooks(functionCallArgs, activeComponentName);
                    vueProvideInject = extractVueProvideInject(functionCallArgs, activeComponentName);
                    vueDirectives = extractVueDirectives(fileInfo.vueMeta.templateAst, activeComponentName, VueNodeTypes);
                }

                // Step 4: Extract CFG (NEW - fixes jsx='preserved' 0 CFG bug)
                // CRITICAL: Skip CFG extraction for jsx='preserved' to prevent double extraction
                // The 'preserved' batch is for JSX-specific symbol extraction only
                let cfg = [];
                if (jsxMode !== 'preserved') {
                    cfg = extractCFG(sourceFile, ts);
                } else {
                    // CFG already extracted in first batch, skip to avoid duplicates
                    cfg = [];
                }

                // Count nodes for complexity metrics
                const nodeCount = countNodes(sourceFile, ts);

                results[fileInfo.original] = {
                    success: true,
                    fileName: fileInfo.absolute,
                    languageVersion: ts.ScriptTarget[sourceFile.languageVersion],
                    ast: null,  // ALWAYS null - no serialization, prevents 512MB crash
                    diagnostics: diagnostics,
                    imports: imports,
                    nodeCount: nodeCount,
                    hasTypes: true,
                    jsxMode: jsxMode,
                    extracted_data: {
                        // PHASE 5: All data types extracted in JavaScript (including CFG)
                        functions: functions,
                        classes: classes,
                        class_properties: classProperties,
                        env_var_usage: envVarUsage,
                        orm_relationships: ormRelationships,
                        calls: calls,
                        imports: imports,
                        assignments: assignments,
                        function_call_args: functionCallArgs,
                        returns: returns,
                        object_literals: objectLiterals,
                        variable_usage: variableUsage,
                        import_styles: importStyles,
                        resolved_imports: refs,
                        react_components: reactComponents,
                        react_hooks: reactHooks,
                        orm_queries: ormQueries,
                        routes: apiEndpoints,  // FIX: Renamed 'api_endpoints' to 'routes' to match Python indexer
                        validation_framework_usage: validationUsage,
                        sql_queries: sqlQueries,
                        vue_components: vueComponents,
                        vue_hooks: vueHooks,
                        vue_directives: vueDirectives,
                        vue_provide_inject: vueProvideInject,
                        scope_map: Object.fromEntries(scopeMap),  // Convert Map to object for JSON
                        cfg: cfg  // CFG extracted in JavaScript (handles JSX nodes correctly)
                    }
                }

            } catch (error) {
                results[fileInfo.original] = {
                    success: false,
                    error: `Error processing file: ${error.message}`,
                    ast: null,
                    diagnostics: [],
                    symbols: []
                };
            } finally {
                if (fileInfo.cleanup) {
                    safeUnlink(fileInfo.cleanup);
                }
            }
        }
    }
    for (const [failedPath, message] of preprocessingErrors.entries()) {
        results[failedPath] = {
            success: false,
            error: message,
            ast: null,
            diagnostics: [],
            symbols: []
        };
    }

    // Write all results
    fs.writeFileSync(outputPath, JSON.stringify(results, null, 2), 'utf8');
    process.exit(0);

} catch (error) {
    console.error(JSON.stringify({
        success: false,
        error: error.message,
        stack: error.stack
    }));
    process.exit(1);
}
