# Architectural Precedent Detection - Database Analysis

**Date**: 2025-11-02
**Task**: Prerequisite #2 for Planning System
**Goal**: Detect architectural precedents (plugin loader patterns) from database queries

---

## Summary: WE CAN DETECT PRECEDENTS FROM DATABASE

**Result**: YES - repo_index.db refs table contains sufficient data to detect plugin loader patterns.

**Found**: 16 plugin loader patterns in TheAuditor codebase using deterministic queries.

**No heuristics needed**: Pattern detection uses import graph analysis, not filename parsing.

---

## The Data Problem (Resolved)

**Initial Concern**:
- refs table stores module NAMES (`schemas.core_schema`)
- Does NOT store resolved FILE PATHS (`theauditor/indexer/schemas/core_schema.py`)
- "Without import resolution, any query is just a guess"

**Resolution**:
- refs table stores TWO formats:
  1. **Python module imports**: `schemas.core_schema` (dotted notation)
  2. **File path imports**: `theauditor/commands/init.py` (slash notation)
- Both formats reveal the directory/prefix structure
- Can group by prefix/directory to find patterns

**Key Insight**: We don't need to know if `schemas.core_schema` resolves to `theauditor/indexer/schemas/core_schema.py`. We only need to know that schema.py imports 9 modules with common prefix `schemas.*` - that's the precedent!

---

## Detection Query (Working Solution)

```sql
-- Find files importing 3+ modules from same directory/prefix
SELECT
    src as consumer_file,
    CASE
        WHEN value LIKE '%/%' THEN substr(value, 1, instr(value, '/') - 1)
        WHEN value LIKE '%.%' THEN substr(value, 1, instr(value, '.') - 1)
    END as directory_prefix,
    COUNT(*) as import_count,
    GROUP_CONCAT(value) as imported_modules
FROM refs
WHERE kind IN ('import', 'from')
  AND src LIKE 'theauditor/%'
GROUP BY src, directory_prefix
HAVING import_count >= 3
ORDER BY import_count DESC;
```

**Handles both formats**:
- File paths: `theauditor/commands/init.py` → prefix: `theauditor`
- Module paths: `schemas.core_schema` → prefix: `schemas`

---

## Discovered Patterns (Top 10)

### 1. cli.py → commands/ (38 files)
**Pattern**: Central command loader
```
theauditor/cli.py imports:
  - theauditor/commands/init.py
  - theauditor/commands/index.py
  - theauditor/commands/blueprint.py
  - theauditor/commands/graph.py
  ... and 34 more
```

### 2. schema.py → schemas/ (9 modules)
**Pattern**: Schema aggregator (the example you mentioned!)
```
theauditor/indexer/schema.py imports:
  - schemas.core_schema
  - schemas.security_schema
  - schemas.frameworks_schema
  - schemas.python_schema
  - schemas.node_schema
  - schemas.infrastructure_schema
  - schemas.planning_schema
  - schemas.graphql_schema
  - schemas.utils
```

### 3. commands/graph.py → graph/ (6 files)
**Pattern**: Graph subsystem loader
```
theauditor/commands/graph.py imports:
  - theauditor/graph/analyzer.py
  - theauditor/graph/builder.py
  - theauditor/graph/dfg_builder.py
  - theauditor/graph/insights.py
  - theauditor/graph/store.py
  - theauditor/graph/visualizer.py
```

### 4. commands/graphql.py → graphql/ (3 files)
**Pattern**: GraphQL subsystem loader
```
theauditor/commands/graphql.py imports:
  - theauditor/graphql/builder.py
  - theauditor/graphql/querier.py
  - theauditor/graphql/visualizer.py
```

### 5. insights/__init__.py → insights/ (5 files)
**Pattern**: Plugin loader with __init__.py aggregator
```
theauditor/insights/__init__.py imports:
  - theauditor/insights/graph.py
  - theauditor/insights/impact_analyzer.py
  - theauditor/insights/ml.py
  - theauditor/insights/semantic_context.py
  - theauditor/insights/taint.py
```

### Other Patterns (6-16):
- commands/insights.py → graph/ (3 files)
- commands/lint.py → utils/ (3 files)
- indexer_compat.py → indexer/ (3 files)
- init.py → theauditor/ (6 files)
- insights/ml.py → sklearn/ (4 modules)
- ... and 6 more

---

## Database Comparison

### repo_index.db (PRIMARY)
**Size**: 155MB
**Import data**: refs table
**Coverage**: 1,979 refs from theauditor/* files
**Formats**:
  - File paths: `theauditor/commands/init.py`
  - Module paths: `schemas.core_schema`
**Status**: ✅ SUFFICIENT for precedent detection
**Availability**: Always present (generated by `aud index`)

### graphs.db (OPTIONAL)
**Size**: 90MB
**Import data**: edges table (type='import')
**Coverage**: 2,474 import edges total
**Formats**:
  - Resolved paths: `theauditor/commands/blueprint.py`
  - External modules: `external::schemas/core_schema`
**Status**: ✅ More complete but NOT REQUIRED
**Availability**: Only if user runs `aud graph build` (optional)

**Conclusion**: Use repo_index.db for precedent detection. Don't depend on graphs.db.

---

## Implementation Plan for Task 1.2

### Step 1: Query repo_index.db for precedents
```python
def detect_plugin_loader_precedents(db_path):
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    cursor.execute('''
        SELECT src, value
        FROM refs
        WHERE src LIKE 'theauditor/%'
          AND kind IN ('import', 'from')
    ''')

    # Group by (consumer, directory/prefix)
    patterns = defaultdict(lambda: defaultdict(set))

    for row in cursor.fetchall():
        source = row['src']
        value = row['value']

        # Extract directory/prefix
        if '/' in value and value.endswith('.py'):
            directory = Path(value).parent.name
        elif '.' in value:
            directory = value.split('.')[0]

        patterns[source][directory].add(value)

    # Filter for 3+ imports
    precedents = []
    for source, dirs in patterns.items():
        for directory, imports in dirs.items():
            if len(imports) >= 3:
                precedents.append({
                    'consumer': source,
                    'directory': directory,
                    'count': len(imports),
                    'imports': sorted(imports)
                })

    return precedents
```

### Step 2: Find refactor candidates
Use symbols table to find files with domain clusters (separate query - not done yet).

### Step 3: Match candidates to precedents
Compare cluster count to precedent import count.

### Step 4: Add to blueprint.py output
Show in `aud blueprint --structure` under new "Architectural Precedents" section.

---

## Key Learnings

1. **refs table has TWO import formats** - file paths (slashes) and module paths (dots)
2. **Python `from X import Y` stored as kind='from'**, not kind='import'
3. **Module resolution not needed** - prefix grouping is sufficient for precedent detection
4. **repo_index.db is sufficient** - don't require graphs.db (optional)
5. **16 patterns found** - proves the data exists and is queryable

---

## Next Steps

1. ✅ Query database to find plugin loader patterns (DONE)
2. ⬜ Find refactor candidates (large files with domain clusters)
3. ⬜ Match candidates to precedents
4. ⬜ Implement in blueprint.py
5. ⬜ Test output in `aud blueprint --structure`

---

## Performance Notes

Query execution time: <0.1 seconds (fast enough for real-time blueprint generation)
No regex needed, no file reads needed, pure database queries.
